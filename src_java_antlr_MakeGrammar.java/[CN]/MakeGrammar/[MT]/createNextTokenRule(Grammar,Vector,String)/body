{
  RuleBlock rb=new RuleBlock(g,rname);
  rb.setDefaultErrorHandler(g.getDefaultErrorHandler());
  RuleEndElement ruleEnd=new RuleEndElement(g);
  rb.setEndElement(ruleEnd);
  ruleEnd.block=rb;
  for (int i=0; i < lexRules.size(); i++) {
    RuleSymbol r=(RuleSymbol)lexRules.elementAt(i);
    if (!r.isDefined()) {
      g.antlrTool.error("Lexer rule " + r.id.substring(1) + " is not defined");
    }
 else {
      if (r.access.equals("public")) {
        Alternative alt=new Alternative();
        RuleBlock targetRuleBlock=r.getBlock();
        Vector targetRuleAlts=targetRuleBlock.getAlternatives();
        if (targetRuleAlts != null && targetRuleAlts.size() == 1) {
          Alternative onlyAlt=(Alternative)targetRuleAlts.elementAt(0);
          if (onlyAlt.semPred != null) {
            alt.semPred=onlyAlt.semPred;
          }
        }
        RuleRefElement rr=new RuleRefElement(g,new CommonToken(ANTLRTokenTypes.RULE_REF,r.getId()),GrammarElement.AUTO_GEN_NONE);
        rr.setLabel("theRetToken");
        rr.enclosingRuleName="nextToken";
        rr.next=ruleEnd;
        alt.addElement(rr);
        alt.setAutoGen(true);
        rb.addAlternative(alt);
        r.addReference(rr);
      }
    }
  }
  rb.setAutoGen(true);
  rb.prepareForAnalysis();
  return rb;
}
