{
  if (text == null) {
    return valueDelimiterStartOfValue + "" + valueDelimiterEndOfValue;
  }
  if (Globals.prefs.putBracesAroundCapitals(fieldName) && !BIBTEX_STRING.equals(fieldName)) {
    text=StringUtil.putBracesAroundCapitals(text);
  }
  if (!text.contains(Globals.NEWLINE) && text.contains("\n")) {
    text=text.replaceAll("\n",Globals.NEWLINE);
  }
  boolean resolveStrings=true;
  if (resolveStringsAllFields) {
    String[] exceptions=doNotResolveStringsFors;
    for (    String exception : exceptions) {
      if (exception.equals(fieldName)) {
        resolveStrings=false;
        break;
      }
    }
  }
 else {
    resolveStrings=BibtexFields.isStandardField(fieldName) || BIBTEX_STRING.equals(fieldName);
  }
  if (!resolveStrings) {
    int numberOfBrackets=0;
    boolean ok=true;
    for (int i=0; i < text.length(); i++) {
      char c=text.charAt(i);
      if (c == '{') {
        numberOfBrackets++;
      }
      if (c == '}') {
        numberOfBrackets--;
      }
      if (numberOfBrackets < 0) {
        ok=false;
        break;
      }
    }
    if (numberOfBrackets > 0) {
      ok=false;
    }
    if (!ok) {
      throw new IllegalArgumentException("Curly braces { and } must be balanced.");
    }
    stringBuilder=new StringBuilder(valueDelimiterStartOfValue + "");
    boolean isAbstract="abstract".equals(fieldName);
    boolean isReview="review".equals(fieldName);
    boolean doWrap=!isAbstract || !isReview;
    boolean strangePrefSettings=writefieldWrapfield && !Globals.prefs.isNonWrappableField(fieldName);
    if (strangePrefSettings && doWrap) {
      stringBuilder.append(parser.format(StringUtil.wrap(text,GUIGlobals.LINE_LENGTH),fieldName));
    }
 else {
      stringBuilder.append(parser.format(text,fieldName));
    }
    stringBuilder.append(valueDelimiterEndOfValue);
    return stringBuilder.toString();
  }
  stringBuilder=new StringBuilder();
  int pivot=0;
  int pos1;
  int pos2;
  checkBraces(text);
  while (pivot < text.length()) {
    int goFrom=pivot;
    pos1=pivot;
    while (goFrom == pos1) {
      pos1=text.indexOf('#',goFrom);
      if (pos1 > 0 && text.charAt(pos1 - 1) == '\\') {
        goFrom=pos1 + 1;
        pos1++;
      }
 else {
        goFrom=pos1 - 1;
      }
    }
    if (pos1 == -1) {
      pos1=text.length();
      pos2=-1;
    }
 else {
      pos2=text.indexOf('#',pos1 + 1);
      if (pos2 == -1) {
        if (!neverFailOnHashes) {
          throw new IllegalArgumentException(Localization.lang("The # character is not allowed in BibTeX strings unless escaped as in '\\#'.") + '\n' + Localization.lang("In JabRef, use pairs of # characters to indicate a string.")+ '\n'+ Localization.lang("Note that the entry causing the problem has been selected."));
        }
 else {
          pos1=text.length();
        }
      }
    }
    if (pos1 > pivot) {
      writeText(text,pivot,pos1);
    }
    if (pos1 < text.length() && pos2 - 1 > pos1) {
      writeStringLabel(text,pos1 + 1,pos2,pos1 == pivot,pos2 + 1 == text.length());
    }
    if (pos2 > -1) {
      pivot=pos2 + 1;
    }
 else {
      pivot=pos1 + 1;
    }
  }
  if (writefieldWrapfield && !Globals.prefs.isNonWrappableField(fieldName)) {
    return parser.format(StringUtil.wrap(stringBuilder.toString(),GUIGlobals.LINE_LENGTH),fieldName);
  }
 else {
    return parser.format(stringBuilder.toString(),fieldName);
  }
}
