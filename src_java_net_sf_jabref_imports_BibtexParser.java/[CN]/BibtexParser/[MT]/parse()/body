{
  _db=new BibtexDatabase();
  _meta=new HashMap();
  entryTypes=new HashMap();
  ParserResult _pr=new ParserResult(_db,_meta,entryTypes);
  skipWhitespace();
  try {
    while (!_eof) {
      consumeUncritically('@');
      skipWhitespace();
      String entryType=parseTextToken();
      BibtexEntryType tp=BibtexEntryType.getType(entryType);
      boolean isEntry=(tp != null);
      if (!isEntry) {
        if (entryType.toLowerCase().equals("preamble")) {
          _db.setPreamble(parsePreamble());
        }
 else         if (entryType.toLowerCase().equals("string")) {
          BibtexString bs=parseString();
          try {
            _db.addString(bs);
          }
 catch (          KeyCollisionException ex) {
            _pr.addWarning(Globals.lang("Duplicate string name") + ": " + bs.getName());
          }
        }
 else         if (entryType.toLowerCase().equals("comment")) {
          StringBuffer commentBuf=parseBracketedTextExactly();
          String comment=commentBuf.toString().replaceAll("[\\x0d\\x0a]","");
          if (comment.substring(0,GUIGlobals.META_FLAG.length()).equals(GUIGlobals.META_FLAG) || comment.substring(0,GUIGlobals.META_FLAG_OLD.length()).equals(GUIGlobals.META_FLAG_OLD)) {
            String rest;
            if (comment.substring(0,GUIGlobals.META_FLAG.length()).equals(GUIGlobals.META_FLAG))             rest=comment.substring(GUIGlobals.META_FLAG.length());
 else             rest=comment.substring(GUIGlobals.META_FLAG_OLD.length());
            int pos=rest.indexOf(':');
            if (pos > 0)             _meta.put(rest.substring(0,pos),rest.substring(pos + 1));
          }
          if (comment.substring(0,GUIGlobals.ENTRYTYPE_FLAG.length()).equals(GUIGlobals.ENTRYTYPE_FLAG)) {
            CustomEntryType typ=CustomEntryType.parseEntryType(comment.toString());
            entryTypes.put(typ.getName().toLowerCase(),typ);
          }
        }
 else {
          tp=new UnknownEntryType(entryType.toLowerCase());
          isEntry=true;
        }
      }
      if (isEntry) {
        BibtexEntry be=parseEntry(tp);
        boolean duplicateKey=_db.insertEntry(be);
        if (duplicateKey)         _pr.addWarning(Globals.lang("duplicate BibTeX key") + ": " + be.getCiteKey()+ " ("+ "Grouping may not work for this entry."+ ")");
 else         if (be.getCiteKey() == null || be.getCiteKey().equals("")) {
          _pr.addWarning(Globals.lang("empty BibTeX key") + ": " + be.getAuthorTitleYear(40)+ " ("+ "Grouping may not work for this entry."+ ")");
        }
      }
      skipWhitespace();
    }
    checkEntryTypes(_pr);
    return _pr;
  }
 catch (  KeyCollisionException kce) {
    throw new IOException("Duplicate ID in bibtex file: " + kce.toString());
  }
}
