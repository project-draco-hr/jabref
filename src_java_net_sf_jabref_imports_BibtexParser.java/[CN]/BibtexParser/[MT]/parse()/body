{
  if (_pr != null)   return _pr;
  _db=new BibtexDatabase();
  _meta=new HashMap();
  entryTypes=new HashMap();
  _pr=new ParserResult(_db,_meta,entryTypes);
  skipWhitespace();
  try {
    while (!_eof) {
      boolean found=consumeUncritically('@');
      if (!found)       break;
      skipWhitespace();
      String entryType=parseTextToken();
      BibtexEntryType tp=BibtexEntryType.getType(entryType);
      boolean isEntry=(tp != null);
      if (!isEntry) {
        if (entryType.toLowerCase().equals("preamble")) {
          _db.setPreamble(parsePreamble());
        }
 else         if (entryType.toLowerCase().equals("string")) {
          BibtexString bs=parseString();
          try {
            _db.addString(bs);
          }
 catch (          KeyCollisionException ex) {
            _pr.addWarning(Globals.lang("Duplicate string name") + ": " + bs.getName());
          }
        }
 else         if (entryType.toLowerCase().equals("comment")) {
          StringBuffer commentBuf=parseBracketedTextExactly();
          String comment=commentBuf.toString().replaceAll("[\\x0d\\x0a]","");
          if (comment.substring(0,Math.min(comment.length(),GUIGlobals.META_FLAG.length())).equals(GUIGlobals.META_FLAG) || comment.substring(0,Math.min(comment.length(),GUIGlobals.META_FLAG_OLD.length())).equals(GUIGlobals.META_FLAG_OLD)) {
            String rest;
            if (comment.substring(0,GUIGlobals.META_FLAG.length()).equals(GUIGlobals.META_FLAG))             rest=comment.substring(GUIGlobals.META_FLAG.length());
 else             rest=comment.substring(GUIGlobals.META_FLAG_OLD.length());
            int pos=rest.indexOf(':');
            if (pos > 0)             _meta.put(rest.substring(0,pos),rest.substring(pos + 1));
          }
          if (comment.substring(0,Math.min(comment.length(),GUIGlobals.ENTRYTYPE_FLAG.length())).equals(GUIGlobals.ENTRYTYPE_FLAG)) {
            CustomEntryType typ=CustomEntryType.parseEntryType(comment);
            entryTypes.put(typ.getName().toLowerCase(),typ);
          }
        }
 else {
          tp=new UnknownEntryType(entryType.toLowerCase());
          isEntry=true;
        }
      }
      if (isEntry) {
        try {
          BibtexEntry be=parseEntry(tp);
          boolean duplicateKey=_db.insertEntry(be);
          if (duplicateKey)           _pr.addWarning(Globals.lang("duplicate BibTeX key") + ": " + be.getCiteKey()+ " ("+ Globals.lang("grouping may not work for this entry")+ ")");
 else           if (be.getCiteKey() == null || be.getCiteKey().equals("")) {
            _pr.addWarning(Globals.lang("empty BibTeX key") + ": " + be.getAuthorTitleYear(40)+ " ("+ Globals.lang("grouping may not work for this entry")+ ")");
          }
        }
 catch (        IOException ex) {
          ex.printStackTrace();
          _pr.addWarning(Globals.lang("Error occured when parsing entry") + ": '" + ex.getMessage()+ "'. "+ Globals.lang("Skipped entry."));
        }
      }
      skipWhitespace();
    }
    checkEntryTypes(_pr);
    return _pr;
  }
 catch (  KeyCollisionException kce) {
    throw new IOException("Duplicate ID in bibtex file: " + kce.toString());
  }
}
