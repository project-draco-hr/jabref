{
  String encoding=prefs.get("defaultEncoding");
  OutputStreamWriter ps=null;
  Object[] keys=database.getKeySet().toArray();
  String key, type;
  Reader reader;
  int c;
  ps=new OutputStreamWriter(new FileOutputStream(outFile),encoding);
  if (lfName.equals("mods")) {
    MODSDatabase md=new MODSDatabase(database);
    try {
      DOMSource source=new DOMSource(md.getDOMrepresentation());
      StreamResult result=new StreamResult(ps);
      Transformer trans=TransformerFactory.newInstance().newTransformer();
      trans.setOutputProperty(OutputKeys.INDENT,"yes");
      trans.transform(source,result);
    }
 catch (    Exception e) {
      throw new Error(e);
    }
    ps.close();
    return;
  }
  try {
    reader=getReader(prefix + lfName + ".begin.layout");
    while ((c=reader.read()) != -1) {
      ps.write((char)c);
    }
    reader.close();
  }
 catch (  IOException ex) {
  }
  TreeSet sorted=getSortedEntries(database,false);
  reader=getReader(prefix + lfName + ".layout");
  LayoutHelper layoutHelper=new LayoutHelper(reader);
  Layout defLayout=layoutHelper.getLayoutFromText(Globals.FORMATTER_PACKAGE);
  reader.close();
  HashMap layouts=new HashMap();
  Layout layout;
  for (Iterator i=sorted.iterator(); i.hasNext(); ) {
    BibtexEntry entry=(BibtexEntry)(i.next());
    type=entry.getType().getName().toLowerCase();
    if (layouts.containsKey(type))     layout=(Layout)layouts.get(type);
 else {
      try {
        reader=getReader(prefix + lfName + "."+ type+ ".layout");
        layoutHelper=new LayoutHelper(reader);
        layout=layoutHelper.getLayoutFromText(Globals.FORMATTER_PACKAGE);
        layouts.put(type,layout);
        reader.close();
      }
 catch (      IOException ex) {
        layout=defLayout;
      }
    }
    ps.write(layout.doLayout(entry,database));
  }
  try {
    reader=getReader(prefix + lfName + ".end.layout");
    while ((c=reader.read()) != -1) {
      ps.write((char)c);
    }
    reader.close();
  }
 catch (  IOException ex) {
  }
  ps.flush();
  ps.close();
}
