{
  TreeMap types=new TreeMap();
  BibtexEntry be=null;
  boolean backup=prefs.getBoolean("backup");
  SaveSession session;
  try {
    session=new SaveSession(file,encoding,backup);
  }
 catch (  IOException e) {
    throw new SaveException(e.getMessage());
  }
  try {
    VerifyingWriter fw=getWriter(file,encoding);
    writeBibFileHeader(fw,encoding);
    writePreamble(fw,database.getPreamble());
    writeStrings(fw,database);
    String pri, sec, ter;
    boolean priD, secD, terD, priBinary=false;
    if (!prefs.getBoolean("saveInStandardOrder")) {
      priBinary=prefs.getBoolean("priBinary");
      pri=prefs.get("priSort");
      sec=prefs.get("secSort");
      ter=prefs.get("terSort");
      priD=prefs.getBoolean("priDescending");
      secD=prefs.getBoolean("secDescending");
      terD=prefs.getBoolean("terDescending");
    }
 else {
      pri="author";
      sec="editor";
      ter="year";
      priD=false;
      secD=false;
      terD=true;
    }
    EntryComparator comp=new EntryComparator(false,false,Globals.KEY_FIELD);
    comp=new EntryComparator(false,terD,ter,comp);
    comp=new EntryComparator(false,secD,sec,comp);
    comp=new EntryComparator(priBinary,priD,pri,comp);
    TreeSet sorter=new TreeSet(new CrossRefEntryComparator(comp));
    if ((bes != null) && (bes.length > 0))     for (int i=0; i < bes.length; i++) {
      sorter.add(bes[i]);
    }
    FieldFormatter ff=new LatexFieldFormatter();
    for (Iterator i=sorter.iterator(); i.hasNext(); ) {
      be=(BibtexEntry)(i.next());
      BibtexEntryType tp=be.getType();
      if (BibtexEntryType.getStandardType(tp.getName()) == null) {
        types.put(tp.getName(),tp);
      }
      be.write(fw,ff,true);
      fw.write(Globals.NEWLINE);
    }
    if (metaData != null) {
      metaData.writeMetaData(fw);
    }
    if (types.size() > 0) {
      for (Iterator i=types.keySet().iterator(); i.hasNext(); ) {
        CustomEntryType tp=(CustomEntryType)types.get(i.next());
        tp.save(fw);
        fw.write(Globals.NEWLINE);
      }
    }
    fw.close();
  }
 catch (  Throwable ex) {
    try {
      session.cancel();
    }
 catch (    IOException e) {
      e.printStackTrace();
      throw new SaveException(ex.getMessage() + "\n" + Globals.lang("Warning: could not complete file repair; your file may " + "have been corrupted. Error message: ")+ e.getMessage());
    }
    throw new SaveException(ex.getMessage(),be);
  }
  return session;
}
