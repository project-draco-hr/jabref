{
  BibtexEntry be=null;
  TreeMap types=new TreeMap();
  boolean backup=prefs.getBoolean("backup");
  int status=NOTHING;
  try {
    initFile(file,backup);
    status=INIT_OK;
  }
 catch (  SaveException e) {
    status=e.getStatus();
    try {
      repairAfterError(file,backup,status);
      throw e;
    }
 catch (    IOException e2) {
      e2.printStackTrace();
    }
  }
  try {
    Writer fw=getWriter(file,encoding);
    writeBibFileHeader(fw,encoding);
    writePreamble(fw,database.getPreamble());
    writeStrings(fw,database);
    Set sorter=getSortedEntries(database,null,true);
    FieldFormatter ff=new LatexFieldFormatter();
    for (Iterator i=sorter.iterator(); i.hasNext(); ) {
      be=(BibtexEntry)(i.next());
      BibtexEntryType tp=be.getType();
      if (BibtexEntryType.getStandardType(tp.getName()) == null) {
        types.put(tp.getName(),tp);
      }
      boolean write=true;
      if (checkSearch && !nonZeroField(be,Globals.SEARCH)) {
        write=false;
      }
      if (checkGroup && !nonZeroField(be,Globals.GROUPSEARCH)) {
        write=false;
      }
      if (write) {
        be.write(fw,ff,true);
        fw.write(Globals.NEWLINE);
      }
    }
    if (metaData != null) {
      metaData.writeMetaData(fw);
    }
    if (types.size() > 0) {
      for (Iterator i=types.keySet().iterator(); i.hasNext(); ) {
        CustomEntryType tp=(CustomEntryType)types.get(i.next());
        tp.save(fw);
        fw.write(Globals.NEWLINE);
      }
    }
    fw.close();
  }
 catch (  Throwable ex) {
    ex.printStackTrace();
    try {
      repairAfterError(file,backup,INIT_OK);
    }
 catch (    IOException e) {
      e.printStackTrace();
      throw new SaveException(ex.getMessage() + "\n" + Globals.lang("Warning: could not complete file repair; your file may " + "have been corrupted. Error message: ")+ e.getMessage());
    }
    throw new SaveException(ex.getMessage(),be);
  }
}
