{
  if (g.debuggingOutput)   semPreds=new Vector();
  setGrammar(g);
  if (!(grammar instanceof ParserGrammar)) {
    tool.panic("Internal error generating parser");
  }
  setupOutput(grammar.getClassName());
  genAST=grammar.buildAST;
  tabs=0;
  genHeader();
  println(behavior.getHeaderAction(""));
  println("import antlr.TokenBuffer;");
  println("import antlr.TokenStreamException;");
  println("import antlr.TokenStreamIOException;");
  println("import antlr.ANTLRException;");
  println("import antlr." + grammar.getSuperClass() + ";");
  println("import antlr.Token;");
  println("import antlr.TokenStream;");
  println("import antlr.RecognitionException;");
  println("import antlr.NoViableAltException;");
  println("import antlr.MismatchedTokenException;");
  println("import antlr.SemanticException;");
  println("import antlr.ParserSharedInputState;");
  println("import antlr.collections.impl.BitSet;");
  println("import antlr.collections.AST;");
  println("import antlr.ASTPair;");
  println("import antlr.collections.impl.ASTArray;");
  println(grammar.preambleAction.getText());
  String sup=null;
  if (grammar.superClass != null)   sup=grammar.superClass;
 else   sup="antlr." + grammar.getSuperClass();
  if (grammar.comment != null) {
    _println(grammar.comment);
  }
  println("public class " + grammar.getClassName() + " extends "+ sup);
  println("       implements " + grammar.tokenManager.getName() + TokenTypesFileSuffix);
  Token tsuffix=(Token)grammar.options.get("classHeaderSuffix");
  if (tsuffix != null) {
    String suffix=Tool.stripFrontBack(tsuffix.getText(),"\"","\"");
    if (suffix != null)     print(", " + suffix);
  }
  println(" {");
  if (grammar.debuggingOutput) {
    println("private static final String _ruleNames[] = {");
    Enumeration ids=grammar.rules.elements();
    int ruleNum=0;
    while (ids.hasMoreElements()) {
      GrammarSymbol sym=(GrammarSymbol)ids.nextElement();
      if (sym instanceof RuleSymbol)       println("  \"" + ((RuleSymbol)sym).getId() + "\",");
    }
    println("};");
  }
  print(processActionForTreeSpecifiers(grammar.classMemberAction.getText(),0,currentRule,null));
  println("");
  println("protected " + grammar.getClassName() + "(TokenBuffer tokenBuf, int k) {");
  println("  super(tokenBuf,k);");
  println("  tokenNames = _tokenNames;");
  if (grammar.debuggingOutput) {
    println("  ruleNames  = _ruleNames;");
    println("  semPredNames = _semPredNames;");
    println("  setupDebugging(tokenBuf);");
  }
  println("}");
  println("");
  println("public " + grammar.getClassName() + "(TokenBuffer tokenBuf) {");
  println("  this(tokenBuf," + grammar.maxk + ");");
  println("}");
  println("");
  println("protected " + grammar.getClassName() + "(TokenStream lexer, int k) {");
  println("  super(lexer,k);");
  println("  tokenNames = _tokenNames;");
  if (grammar.debuggingOutput) {
    println("  ruleNames  = _ruleNames;");
    println("  semPredNames = _semPredNames;");
    println("  setupDebugging(lexer);");
  }
  println("}");
  println("");
  println("public " + grammar.getClassName() + "(TokenStream lexer) {");
  println("  this(lexer," + grammar.maxk + ");");
  println("}");
  println("");
  println("public " + grammar.getClassName() + "(ParserSharedInputState state) {");
  println("  super(state," + grammar.maxk + ");");
  println("  tokenNames = _tokenNames;");
  println("}");
  println("");
  Enumeration ids=grammar.rules.elements();
  int ruleNum=0;
  while (ids.hasMoreElements()) {
    GrammarSymbol sym=(GrammarSymbol)ids.nextElement();
    if (sym instanceof RuleSymbol) {
      RuleSymbol rs=(RuleSymbol)sym;
      genRule(rs,rs.references.size() == 0,ruleNum++);
    }
    exitIfError();
  }
  genTokenStrings();
  genBitsets(bitsetsUsed,grammar.tokenManager.maxTokenType());
  if (grammar.debuggingOutput)   genSemPredMap();
  println("");
  println("}");
  currentOutput.close();
  currentOutput=null;
}
