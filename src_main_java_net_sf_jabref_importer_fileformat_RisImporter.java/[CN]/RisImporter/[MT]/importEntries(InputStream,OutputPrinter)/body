{
  ArrayList<BibtexEntry> bibitems=new ArrayList<>();
  StringBuilder sb=new StringBuilder();
  BufferedReader in=new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
  String str;
  while ((str=in.readLine()) != null) {
    sb.append(str);
    sb.append("\n");
  }
  String[] entries=sb.toString().replaceAll("\u2013","-").replaceAll("\u2014","--").replaceAll("\u2015","--").split("ER  -.*\\n");
  for (  String entry1 : entries) {
    if (entry1.trim().isEmpty()) {
      continue;
    }
    String type="";
    String author="";
    String editor="";
    String startPage="";
    String endPage="";
    String comment="";
    HashMap<String,String> hm=new HashMap<>();
    String[] fields=entry1.split("\n");
    for (int j=0; j < fields.length; j++) {
      StringBuilder current=new StringBuilder(fields[j]);
      boolean done=false;
      while (!done && (j < (fields.length - 1))) {
        if ((fields[j + 1].length() >= 6) && !fields[j + 1].substring(2,6).equals("  - ")) {
          if ((current.length() > 0) && !Character.isWhitespace(current.charAt(current.length() - 1)) && !Character.isWhitespace(fields[j + 1].charAt(0))) {
            current.append(' ');
          }
          current.append(fields[j + 1]);
          j++;
        }
 else {
          done=true;
        }
      }
      String entry=current.toString();
      if (entry.length() < 6) {
        continue;
      }
 else {
        String lab=entry.substring(0,2);
        String val=entry.substring(6).trim();
        if (lab.equals("TY")) {
          if (val.equals("BOOK")) {
            type="book";
          }
 else           if (val.equals("JOUR") || val.equals("MGZN")) {
            type="article";
          }
 else           if (val.equals("THES")) {
            type="phdthesis";
          }
 else           if (val.equals("UNPB")) {
            type="unpublished";
          }
 else           if (val.equals("RPRT")) {
            type="techreport";
          }
 else           if (val.equals("CONF")) {
            type="inproceedings";
          }
 else           if (val.equals("CHAP")) {
            type="incollection";
          }
 else {
            type="other";
          }
        }
 else         if (lab.equals("T1") || lab.equals("TI")) {
          String oldVal=hm.get("title");
          if (oldVal == null) {
            hm.put("title",val);
          }
 else {
            if (oldVal.endsWith(":") || oldVal.endsWith(".") || oldVal.endsWith("?")) {
              hm.put("title",oldVal + " " + val);
            }
 else {
              hm.put("title",oldVal + ": " + val);
            }
          }
        }
 else         if (lab.equals("T2") || lab.equals("T3") || lab.equals("BT")) {
          hm.put("booktitle",val);
        }
 else         if (lab.equals("AU") || lab.equals("A1")) {
          if (author.equals("")) {
            author=val;
          }
 else {
            author+=" and " + val;
          }
        }
 else         if (lab.equals("A2")) {
          if (editor.equals("")) {
            editor=val;
          }
 else {
            editor+=" and " + val;
          }
        }
 else         if (lab.equals("JA") || lab.equals("JF") || lab.equals("JO")) {
          if (type.equals("inproceedings")) {
            hm.put("booktitle",val);
          }
 else {
            hm.put("journal",val);
          }
        }
 else         if (lab.equals("SP")) {
          startPage=val;
        }
 else         if (lab.equals("PB")) {
          if (type.equals("phdthesis")) {
            hm.put("school",val);
          }
 else {
            hm.put("publisher",val);
          }
        }
 else         if (lab.equals("AD") || lab.equals("CY")) {
          hm.put("address",val);
        }
 else         if (lab.equals("EP")) {
          endPage=val;
        }
 else         if (lab.equals("SN")) {
          hm.put("issn",val);
        }
 else         if (lab.equals("VL")) {
          hm.put("volume",val);
        }
 else         if (lab.equals("IS")) {
          hm.put("number",val);
        }
 else         if (lab.equals("N2") || lab.equals("AB")) {
          String oldAb=hm.get("abstract");
          if (oldAb == null) {
            hm.put("abstract",val);
          }
 else {
            hm.put("abstract",oldAb + "\n" + val);
          }
        }
 else         if (lab.equals("UR")) {
          hm.put("url",val);
        }
 else         if ((lab.equals("Y1") || lab.equals("PY")) && (val.length() >= 4)) {
          String[] parts=val.split("/");
          hm.put("year",parts[0]);
          if ((parts.length > 1) && !parts[1].isEmpty()) {
            try {
              int monthNumber=Integer.parseInt(parts[1]);
              MonthUtil.Month month=MonthUtil.getMonthByNumber(monthNumber);
              if (month.isValid()) {
                hm.put("month",month.bibtexFormat);
              }
            }
 catch (            NumberFormatException ex) {
            }
          }
        }
 else         if (lab.equals("KW")) {
          if (!hm.containsKey("keywords")) {
            hm.put("keywords",val);
          }
 else {
            String kw=hm.get("keywords");
            hm.put("keywords",kw + ", " + val);
          }
        }
 else         if (lab.equals("U1") || lab.equals("U2") || lab.equals("N1")) {
          if (!comment.isEmpty()) {
            comment=comment + "\n";
          }
          comment=comment + val;
        }
 else         if (lab.equals("ID")) {
          hm.put("refid",val);
        }
 else         if (lab.equals("M3")) {
          String doi=val;
          if (doi.startsWith("doi:")) {
            doi=doi.replaceAll("(?i)doi:","").trim();
            hm.put("doi",doi);
          }
        }
      }
      if (!author.isEmpty()) {
        author=AuthorList.fixAuthor_lastNameFirst(author);
        hm.put("author",author);
      }
      if (!editor.isEmpty()) {
        editor=AuthorList.fixAuthor_lastNameFirst(editor);
        hm.put("editor",editor);
      }
      if (!comment.isEmpty()) {
        hm.put("comment",comment);
      }
      hm.put("pages",startPage + "--" + endPage);
    }
    BibtexEntry b=new BibtexEntry(DEFAULT_BIBTEXENTRY_ID,BibtexEntryTypes.getEntryType(type));
    ArrayList<Object> toRemove=new ArrayList<>();
    for (    String key : hm.keySet()) {
      String content=hm.get(key);
      if ((content == null) || content.trim().isEmpty()) {
        toRemove.add(key);
      }
    }
    for (    Object aToRemove : toRemove) {
      hm.remove(aToRemove);
    }
    b.setField(hm);
    bibitems.add(b);
  }
  return bibitems;
}
