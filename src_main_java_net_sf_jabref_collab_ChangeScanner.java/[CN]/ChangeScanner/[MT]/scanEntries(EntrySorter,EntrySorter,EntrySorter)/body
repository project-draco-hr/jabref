{
  int piv1, piv2=0;
  HashSet<String> used=new HashSet<String>(disk.getEntryCount());
  HashSet<Integer> notMatched=new HashSet<Integer>(tmp.getEntryCount());
  mainLoop:   for (piv1=0; piv1 < tmp.getEntryCount(); piv1++) {
    double comp=-1;
    if (!used.contains("" + piv2) && piv2 < disk.getEntryCount()) {
      comp=DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1),disk.getEntryAt(piv2));
    }
    if (comp > 1) {
      used.add("" + piv2);
      piv2++;
      continue;
    }
    if (piv2 < disk.getEntryCount() - 1) {
      for (int i=piv2 + 1; i < disk.getEntryCount(); i++) {
        if (!used.contains("" + i)) {
          comp=DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1),disk.getEntryAt(i));
        }
 else {
          comp=-1;
        }
        if (comp > 1) {
          used.add("" + i);
          continue mainLoop;
        }
      }
    }
    notMatched.add(piv1);
  }
  if (!notMatched.isEmpty()) {
    for (Iterator<Integer> it=notMatched.iterator(); it.hasNext(); ) {
      piv1=it.next();
      int bestMatchI=-1;
      double bestMatch=0;
      double comp;
      if (piv2 < disk.getEntryCount() - 1) {
        for (int i=piv2; i < disk.getEntryCount(); i++) {
          if (!used.contains("" + i)) {
            comp=DuplicateCheck.compareEntriesStrictly(tmp.getEntryAt(piv1),disk.getEntryAt(i));
          }
 else {
            comp=-1;
          }
          if (comp > bestMatch) {
            bestMatch=comp;
            bestMatchI=i;
          }
        }
      }
      double MATCH_THRESHOLD=0.4;
      if (bestMatch > MATCH_THRESHOLD) {
        used.add("" + bestMatchI);
        it.remove();
        EntryChange ec=new EntryChange(bestFit(tmp,mem,piv1),tmp.getEntryAt(piv1),disk.getEntryAt(bestMatchI));
        changes.add(ec);
      }
 else {
        EntryDeleteChange ec=new EntryDeleteChange(bestFit(tmp,mem,piv1),tmp.getEntryAt(piv1));
        changes.add(ec);
      }
    }
  }
  if (used.size() < disk.getEntryCount()) {
    for (int i=0; i < disk.getEntryCount(); i++) {
      if (!used.contains("" + i)) {
        boolean hasAlready=false;
        for (int j=0; j < mem.getEntryCount(); j++) {
          if (DuplicateCheck.compareEntriesStrictly(mem.getEntryAt(j),disk.getEntryAt(i)) >= 1) {
            hasAlready=true;
            break;
          }
        }
        if (!hasAlready) {
          EntryAddChange ec=new EntryAddChange(disk.getEntryAt(i));
          changes.add(ec);
        }
      }
    }
  }
}
