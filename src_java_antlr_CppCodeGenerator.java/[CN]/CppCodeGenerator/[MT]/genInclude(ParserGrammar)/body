{
  outputFile=grammar.getClassName() + ".hpp";
  outputLine=1;
  currentOutput=antlrTool.openOutputFile(outputFile);
  genAST=grammar.buildAST;
  tabs=0;
  println("#ifndef INC_" + grammar.getClassName() + "_hpp_");
  println("#define INC_" + grammar.getClassName() + "_hpp_");
  println("");
  printHeaderAction(preIncludeHpp);
  println("#include <antlr/config.hpp>");
  genHeader(outputFile);
  println("#include <antlr/TokenStream.hpp>");
  println("#include <antlr/TokenBuffer.hpp>");
  println("#include \"" + grammar.tokenManager.getName() + TokenTypesFileSuffix+ ".hpp\"");
  String sup=null;
  if (grammar.superClass != null) {
    sup=grammar.superClass;
    println("\n// Include correct superclass header with a header statement for example:");
    println("// header \"post_include_hpp\" {");
    println("// #include \"" + sup + ".hpp\"");
    println("// }");
    println("// Or....");
    println("// header {");
    println("// #include \"" + sup + ".hpp\"");
    println("// }\n");
  }
 else {
    sup=grammar.getSuperClass();
    if (sup.lastIndexOf('.') != -1)     sup=sup.substring(sup.lastIndexOf('.') + 1);
    println("#include <antlr/" + sup + ".hpp>");
    sup=namespaceAntlr + sup;
  }
  println("");
  printHeaderAction(postIncludeHpp);
  if (nameSpace != null)   nameSpace.emitDeclarations(currentOutput);
  printHeaderAction("");
  if (grammar.comment != null) {
    _println(grammar.comment);
  }
  print("class CUSTOM_API " + grammar.getClassName() + " : public "+ sup);
  println(", public " + grammar.tokenManager.getName() + TokenTypesFileSuffix);
  Token tsuffix=(Token)grammar.options.get("classHeaderSuffix");
  if (tsuffix != null) {
    String suffix=StringUtils.stripFrontBack(tsuffix.getText(),"\"","\"");
    if (suffix != null)     print(", " + suffix);
  }
  println("{");
  if (grammar.debuggingOutput) {
    println("public: static const char* _ruleNames[];");
  }
  if (grammar.classMemberAction != null) {
    genLineNo(grammar.classMemberAction.getLine());
    print(processActionForSpecialSymbols(grammar.classMemberAction.getText(),grammar.classMemberAction.getLine(),currentRule,null));
    genLineNo2();
  }
  println("public:");
  tabs=1;
  println("void initializeASTFactory( " + namespaceAntlr + "ASTFactory& factory );");
  tabs=0;
  if (noConstructors) {
    println("#if 0");
    println("// constructor creation turned of with 'noConstructor' option");
  }
  println("protected:");
  tabs=1;
  println(grammar.getClassName() + "(" + namespaceAntlr+ "TokenBuffer& tokenBuf, int k);");
  tabs=0;
  println("public:");
  tabs=1;
  println(grammar.getClassName() + "(" + namespaceAntlr+ "TokenBuffer& tokenBuf);");
  tabs=0;
  println("protected:");
  tabs=1;
  println(grammar.getClassName() + "(" + namespaceAntlr+ "TokenStream& lexer, int k);");
  tabs=0;
  println("public:");
  tabs=1;
  println(grammar.getClassName() + "(" + namespaceAntlr+ "TokenStream& lexer);");
  println(grammar.getClassName() + "(const " + namespaceAntlr+ "ParserSharedInputState& state);");
  if (noConstructors) {
    tabs=0;
    println("// constructor creation turned of with 'noConstructor' option");
    println("#endif");
    tabs=1;
  }
  println("int getNumTokens() const");
  println("{");
  tabs++;
  println("return " + grammar.getClassName() + "::NUM_TOKENS;");
  tabs--;
  println("}");
  println("const char* getTokenName( int type ) const");
  println("{");
  tabs++;
  println("if( type > getNumTokens() ) return 0;");
  println("return " + grammar.getClassName() + "::tokenNames[type];");
  tabs--;
  println("}");
  println("const char* const* getTokenNames() const");
  println("{");
  tabs++;
  println("return " + grammar.getClassName() + "::tokenNames;");
  tabs--;
  println("}");
  Enumeration ids=grammar.rules.elements();
  while (ids.hasMoreElements()) {
    GrammarSymbol sym=(GrammarSymbol)ids.nextElement();
    if (sym instanceof RuleSymbol) {
      RuleSymbol rs=(RuleSymbol)sym;
      genRuleHeader(rs,rs.references.size() == 0);
    }
    exitIfError();
  }
  tabs=0;
  println("public:");
  tabs=1;
  println(namespaceAntlr + "RefAST getAST()");
  println("{");
  if (usingCustomAST) {
    tabs++;
    println("return " + namespaceAntlr + "RefAST(returnAST);");
    tabs--;
  }
 else {
    tabs++;
    println("return returnAST;");
    tabs--;
  }
  println("}");
  println("");
  tabs=0;
  println("protected:");
  tabs=1;
  println(labeledElementASTType + " returnAST;");
  tabs=0;
  println("private:");
  tabs=1;
  println("static const char* tokenNames[];");
  _println("#ifndef NO_STATIC_CONSTS");
  println("static const int NUM_TOKENS = " + grammar.tokenManager.getVocabulary().size() + ";");
  _println("#else");
  println("enum {");
  println("\tNUM_TOKENS = " + grammar.tokenManager.getVocabulary().size());
  println("};");
  _println("#endif");
  genBitsetsHeader(bitsetsUsed,grammar.tokenManager.maxTokenType());
  if (grammar.debuggingOutput)   println("static const char* _semPredNames[];");
  tabs=0;
  println("};");
  println("");
  if (nameSpace != null)   nameSpace.emitClosures(currentOutput);
  println("#endif /*INC_" + grammar.getClassName() + "_hpp_*/");
  currentOutput.close();
  currentOutput=null;
}
