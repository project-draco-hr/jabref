{
  outputFile=grammar.getClassName() + ".hpp";
  outputLine=1;
  currentOutput=antlrTool.openOutputFile(outputFile);
  genAST=false;
  saveText=true;
  tabs=0;
  println("#ifndef INC_" + grammar.getClassName() + "_hpp_");
  println("#define INC_" + grammar.getClassName() + "_hpp_");
  println("");
  printHeaderAction(preIncludeHpp);
  println("#include <antlr/config.hpp>");
  genHeader(outputFile);
  println("#include <antlr/CommonToken.hpp>");
  println("#include <antlr/InputBuffer.hpp>");
  println("#include <antlr/BitSet.hpp>");
  println("#include \"" + grammar.tokenManager.getName() + TokenTypesFileSuffix+ ".hpp\"");
  String sup=null;
  if (grammar.superClass != null) {
    sup=grammar.superClass;
    println("\n// Include correct superclass header with a header statement for example:");
    println("// header \"post_include_hpp\" {");
    println("// #include \"" + sup + ".hpp\"");
    println("// }");
    println("// Or....");
    println("// header {");
    println("// #include \"" + sup + ".hpp\"");
    println("// }\n");
  }
 else {
    sup=grammar.getSuperClass();
    if (sup.lastIndexOf('.') != -1)     sup=sup.substring(sup.lastIndexOf('.') + 1);
    println("#include <antlr/" + sup + ".hpp>");
    sup=namespaceAntlr + sup;
  }
  printHeaderAction(postIncludeHpp);
  if (nameSpace != null)   nameSpace.emitDeclarations(currentOutput);
  printHeaderAction("");
  if (grammar.comment != null) {
    _println(grammar.comment);
  }
  print("class CUSTOM_API " + grammar.getClassName() + " : public "+ sup);
  println(", public " + grammar.tokenManager.getName() + TokenTypesFileSuffix);
  Token tsuffix=(Token)grammar.options.get("classHeaderSuffix");
  if (tsuffix != null) {
    String suffix=StringUtils.stripFrontBack(tsuffix.getText(),"\"","\"");
    if (suffix != null) {
      print(", " + suffix);
    }
  }
  println("{");
  if (grammar.classMemberAction != null) {
    genLineNo(grammar.classMemberAction);
    print(processActionForSpecialSymbols(grammar.classMemberAction.getText(),grammar.classMemberAction.getLine(),currentRule,null));
    genLineNo2();
  }
  tabs=0;
  println("private:");
  tabs=1;
  println("void initLiterals();");
  tabs=0;
  println("public:");
  tabs=1;
  println("bool getCaseSensitiveLiterals() const");
  println("{");
  tabs++;
  println("return " + g.caseSensitiveLiterals + ";");
  tabs--;
  println("}");
  tabs=0;
  println("public:");
  tabs=1;
  if (noConstructors) {
    tabs=0;
    println("#if 0");
    println("// constructor creation turned of with 'noConstructor' option");
    tabs=1;
  }
  println(grammar.getClassName() + "(" + namespaceStd+ "istream& in);");
  println(grammar.getClassName() + "(" + namespaceAntlr+ "InputBuffer& ib);");
  println(grammar.getClassName() + "(const " + namespaceAntlr+ "LexerSharedInputState& state);");
  if (noConstructors) {
    tabs=0;
    println("// constructor creation turned of with 'noConstructor' option");
    println("#endif");
    tabs=1;
  }
  println(namespaceAntlr + "RefToken nextToken();");
  Enumeration ids=grammar.rules.elements();
  while (ids.hasMoreElements()) {
    RuleSymbol sym=(RuleSymbol)ids.nextElement();
    if (!sym.getId().equals("mnextToken")) {
      genRuleHeader(sym,false);
    }
    exitIfError();
  }
  tabs=0;
  println("private:");
  tabs=1;
  if (grammar.debuggingOutput) {
    println("static const char* _ruleNames[];");
  }
  if (grammar.debuggingOutput)   println("static const char* _semPredNames[];");
  genBitsetsHeader(bitsetsUsed,((LexerGrammar)grammar).charVocabulary.size());
  tabs=0;
  println("};");
  println("");
  if (nameSpace != null)   nameSpace.emitClosures(currentOutput);
  println("#endif /*INC_" + grammar.getClassName() + "_hpp_*/");
  currentOutput.close();
  currentOutput=null;
}
