{
  outputFile=grammar.getClassName() + ".hpp";
  outputLine=1;
  currentOutput=antlr.Tool.openOutputFile(outputFile);
  genAST=false;
  saveText=true;
  tabs=0;
  println("#ifndef INC_" + grammar.getClassName() + "_hpp_");
  println("#define INC_" + grammar.getClassName() + "_hpp_");
  println("");
  printHeaderAction(preIncludeHpp);
  println("#include \"antlr/config.hpp\"");
  genHeader(outputFile);
  println("#include \"antlr/CommonToken.hpp\"");
  println("#include \"antlr/InputBuffer.hpp\"");
  println("#include \"antlr/BitSet.hpp\"");
  println("#include \"" + grammar.tokenManager.getName() + TokenTypesFileSuffix+ ".hpp\"");
  String sup=null;
  if (grammar.superClass != null) {
    sup=grammar.superClass;
    println("#include \"" + sup + ".hpp\"");
  }
 else {
    sup=grammar.getSuperClass();
    if (sup.lastIndexOf('.') != -1)     sup=sup.substring(sup.lastIndexOf('.') + 1);
    println("#include \"antlr/" + sup + ".hpp\"");
    sup=namespaceAntlr + sup;
  }
  printHeaderAction(postIncludeHpp);
  if (nameSpace != null)   nameSpace.emitDeclarations(currentOutput);
  printHeaderAction("");
  if (grammar.comment != null) {
    _println(grammar.comment);
  }
  print("class " + grammar.getClassName() + " : public "+ sup);
  println(", public " + grammar.tokenManager.getName() + TokenTypesFileSuffix);
  Token tsuffix=(Token)grammar.options.get("classHeaderSuffix");
  if (tsuffix != null) {
    String suffix=Tool.stripFrontBack(tsuffix.getText(),"\"","\"");
    if (suffix != null) {
      print(", " + suffix);
    }
  }
  println(" {");
  if (grammar.classMemberAction != null) {
    genLineNo(grammar.classMemberAction);
    print(processActionForTreeSpecifiers(grammar.classMemberAction.getText(),0,currentRule,null));
    genLineNo2();
  }
  tabs=0;
  println("private:");
  tabs=1;
  println("void initLiterals();");
  tabs=0;
  println("public:");
  tabs=1;
  println("bool getCaseSensitiveLiterals() const;");
  tabs=0;
  println("public:");
  tabs=1;
  println(grammar.getClassName() + "(" + namespaceStd+ "istream& in);");
  println(grammar.getClassName() + "(" + namespaceAntlr+ "InputBuffer& ib);");
  println(grammar.getClassName() + "(const " + namespaceAntlr+ "LexerSharedInputState& state);");
  println(namespaceAntlr + "RefToken nextToken();");
  Enumeration ids=grammar.rules.elements();
  while (ids.hasMoreElements()) {
    RuleSymbol sym=(RuleSymbol)ids.nextElement();
    if (!sym.getId().equals("mnextToken")) {
      genRuleHeader(sym,false);
    }
    exitIfError();
  }
  tabs=0;
  println("private:");
  tabs=1;
  if (grammar.debuggingOutput) {
    println("static const char* _ruleNames[];");
  }
  if (grammar.debuggingOutput)   println("static const char* _semPredNames[];");
  genBitsetsHeader(bitsetsUsed,((LexerGrammar)grammar).charVocabulary.size());
  tabs=0;
  println("};");
  println("");
  if (nameSpace != null)   nameSpace.emitClosures(currentOutput);
  println("#endif /*INC_" + grammar.getClassName() + "_hpp_*/");
  currentOutput.close();
  currentOutput=null;
}
