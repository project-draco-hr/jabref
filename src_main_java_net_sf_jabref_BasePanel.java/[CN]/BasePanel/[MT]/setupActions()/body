{
  saveAction=new SaveDatabaseAction(this);
  CleanUpAction cleanUpAction=new CleanUpAction(this);
  actions.put("undo",undoAction);
  actions.put("redo",redoAction);
  actions.put("focusTable",new BaseAction(){
    @Override public void action() throws Throwable {
      new FocusRequester(mainTable);
    }
  }
);
  actions.put("edit",new BaseAction(){
    @Override public void action(){
      selectionListener.editSignalled();
    }
  }
);
  actions.put("test",new FindFullTextAction(this));
  actions.put("save",saveAction);
  actions.put("saveAs",new BaseAction(){
    @Override public void action() throws Throwable {
      saveAction.saveAs();
    }
  }
);
  actions.put("saveSelectedAs",new SaveSelectedAction(FileActions.DatabaseSaveType.DEFAULT));
  actions.put("saveSelectedAsPlain",new SaveSelectedAction(FileActions.DatabaseSaveType.PLAIN_BIBTEX));
  actions.put("copy",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        TransferableBibtexEntry trbe=new TransferableBibtexEntry(bes);
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(trbe,BasePanel.this);
        output(Localization.lang("Copied") + ' ' + (bes.length > 1 ? bes.length + " " + Localization.lang("entries") : "1 " + Localization.lang("entry") + '.'));
      }
 else {
        int[] rows=mainTable.getSelectedRows();
        int[] cols=mainTable.getSelectedColumns();
        if (cols.length == 1 && rows.length == 1) {
          Object o=mainTable.getValueAt(rows[0],cols[0]);
          if (o != null) {
            StringSelection ss=new StringSelection(o.toString());
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
            output(Localization.lang("Copied cell contents") + '.');
          }
        }
      }
    }
  }
);
  actions.put("cut",new BaseAction(){
    @Override public void action() throws Throwable {
      runCommand("copy");
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        NamedCompound ce=new NamedCompound(Localization.lang(bes.length > 1 ? "cut entries" : "cut entry"));
        for (        BibtexEntry be : bes) {
          database.removeEntry(be.getId());
          ensureNotShowing(be);
          ce.addEdit(new UndoableRemoveEntry(database,be,BasePanel.this));
        }
        frame.output(Localization.lang("Cut_pr") + ' ' + (bes.length > 1 ? bes.length + " " + Localization.lang("entries") : Localization.lang("entry"))+ '.');
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
      }
    }
  }
);
  actions.put("delete",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        boolean goOn=showDeleteConfirmationDialog(bes.length);
        if (goOn) {
          NamedCompound ce=new NamedCompound(Localization.lang(bes.length > 1 ? "delete entries" : "delete entry"));
          for (          BibtexEntry be : bes) {
            database.removeEntry(be.getId());
            ensureNotShowing(be);
            ce.addEdit(new UndoableRemoveEntry(database,be,BasePanel.this));
          }
          markBaseChanged();
          frame.output(Localization.lang("Deleted") + ' ' + (bes.length > 1 ? bes.length + " " + Localization.lang("entries") : Localization.lang("entry"))+ '.');
          ce.end();
          undoManager.addEdit(ce);
        }
      }
    }
  }
);
  actions.put("paste",new BaseAction(){
    @Override public void action(){
      Transferable content=Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null);
      if (content != null) {
        BibtexEntry[] bes=null;
        if (content.isDataFlavorSupported(TransferableBibtexEntry.entryFlavor)) {
          try {
            bes=(BibtexEntry[])content.getTransferData(TransferableBibtexEntry.entryFlavor);
          }
 catch (          UnsupportedFlavorException ex) {
            ex.printStackTrace();
          }
catch (          IOException ex) {
            ex.printStackTrace();
          }
        }
 else         if (content.isDataFlavorSupported(DataFlavor.stringFlavor)) {
          try {
            BibtexParser bp=new BibtexParser(new java.io.StringReader((String)content.getTransferData(DataFlavor.stringFlavor)));
            BibtexDatabase db=bp.parse().getDatabase();
            LOGGER.info("Parsed " + db.getEntryCount() + " entries from clipboard text");
            if (db.getEntryCount() > 0) {
              bes=db.getEntries().toArray(new BibtexEntry[db.getEntryCount()]);
            }
          }
 catch (          UnsupportedFlavorException ex) {
            ex.printStackTrace();
          }
catch (          Throwable ex) {
            ex.printStackTrace();
          }
        }
        if (bes != null && bes.length > 0) {
          NamedCompound ce=new NamedCompound(Localization.lang(bes.length > 1 ? "paste entries" : "paste entry"));
          BibtexEntry firstBE=null;
          for (          BibtexEntry be1 : bes) {
            try {
              BibtexEntry be=(BibtexEntry)be1.clone();
              if (firstBE == null) {
                firstBE=be;
              }
              Util.setAutomaticFields(be,Globals.prefs.getBoolean(JabRefPreferences.OVERWRITE_OWNER),Globals.prefs.getBoolean(JabRefPreferences.OVERWRITE_TIME_STAMP));
              be.setId(IdGenerator.next());
              database.insertEntry(be);
              ce.addEdit(new UndoableInsertEntry(database,be,BasePanel.this));
            }
 catch (            KeyCollisionException ex) {
              LOGGER.info("KeyCollisionException... this shouldn't happen.",ex);
            }
          }
          ce.end();
          undoManager.addEdit(ce);
          output(Localization.lang("Pasted") + ' ' + (bes.length > 1 ? bes.length + " " + Localization.lang("entries") : "1 " + Localization.lang("entry"))+ '.');
          markBaseChanged();
          if (Globals.prefs.getBoolean(JabRefPreferences.AUTO_OPEN_FORM)) {
            selectionListener.editSignalled(firstBE);
          }
          highlightEntry(firstBE);
        }
      }
    }
  }
);
  actions.put("selectAll",new BaseAction(){
    @Override public void action(){
      mainTable.selectAll();
    }
  }
);
  actions.put("editPreamble",new BaseAction(){
    @Override public void action(){
      if (preambleEditor == null) {
        PreambleEditor form=new PreambleEditor(frame,BasePanel.this,database,Globals.prefs);
        Util.placeDialog(form,frame);
        form.setVisible(true);
        preambleEditor=form;
      }
 else {
        preambleEditor.setVisible(true);
      }
    }
  }
);
  actions.put("editStrings",new BaseAction(){
    @Override public void action(){
      if (stringDialog == null) {
        StringDialog form=new StringDialog(frame,BasePanel.this,database,Globals.prefs);
        Util.placeDialog(form,frame);
        form.setVisible(true);
        stringDialog=form;
      }
 else {
        stringDialog.setVisible(true);
      }
    }
  }
);
  actions.put("toggleGroups",new BaseAction(){
    @Override public void action(){
      sidePaneManager.toggle("groups");
      frame.groupToggle.setSelected(sidePaneManager.isComponentVisible("groups"));
    }
  }
);
  actions.put("toggleToolbar",new BaseAction(){
    @Override public void action(){
      frame.tlb.setVisible(!frame.tlb.isVisible());
    }
  }
);
  actions.put("dbConnect",new DbConnectAction(this));
  actions.put("dbExport",new AbstractWorker(){
    String errorMessage;
    boolean connectToDB;
    @Override public void init(){
      DBStrings dbs=metaData.getDBStrings();
      if (!dbs.isConfigValid()) {
        if (!dbs.isInitialized()) {
          dbs.initialize();
        }
        DBConnectDialog dbd=new DBConnectDialog(frame(),dbs);
        Util.placeDialog(dbd,BasePanel.this);
        dbd.setVisible(true);
        connectToDB=dbd.getConnectToDB();
        if (connectToDB) {
          dbs=dbd.getDBStrings();
          metaData.setDBStrings(dbs);
          dbd.dispose();
        }
      }
 else {
        connectToDB=true;
      }
    }
    @Override public void run(){
      if (connectToDB) {
        DBStrings dbs=metaData.getDBStrings();
        try {
          frame.output(Localization.lang("Attempting SQL export..."));
          DBExporterAndImporterFactory factory=new DBExporterAndImporterFactory();
          DBExporter exporter=factory.getExporter(dbs.getServerType());
          exporter.exportDatabaseToDBMS(database,metaData,null,dbs,frame);
          dbs.isConfigValid(true);
        }
 catch (        Exception ex) {
          String preamble="Could not export to SQL database for the following reason:";
          errorMessage=SQLUtil.getExceptionMessage(ex);
          ex.printStackTrace();
          dbs.isConfigValid(false);
          JOptionPane.showMessageDialog(frame,Localization.lang(preamble) + '\n' + errorMessage,Localization.lang("Export to SQL database"),JOptionPane.ERROR_MESSAGE);
        }
        metaData.setDBStrings(dbs);
      }
    }
    @Override public void update(){
      if (errorMessage == null) {
        if (connectToDB) {
          frame.output(Localization.lang("%0 export successful"));
        }
      }
 else {
        String preamble="Could not export to SQL database for the following reason:";
        frame.output(Localization.lang(preamble) + "  " + errorMessage);
        JOptionPane.showMessageDialog(frame,Localization.lang(preamble) + '\n' + errorMessage,Localization.lang("Export to SQL database"),JOptionPane.ERROR_MESSAGE);
        errorMessage=null;
      }
    }
  }
);
  actions.put(FindUnlinkedFilesDialog.ACTION_COMMAND,new BaseAction(){
    @Override public void action() throws Throwable {
      FindUnlinkedFilesDialog dialog=new FindUnlinkedFilesDialog(frame,frame,BasePanel.this);
      Util.placeDialog(dialog,frame);
      dialog.setVisible(true);
    }
  }
);
  actions.put("makeKey",new AbstractWorker(){
    List<BibtexEntry> entries;
    int numSelected;
    boolean cancelled;
    @Override public void init(){
      entries=new ArrayList<BibtexEntry>(Arrays.asList(getSelectedEntries()));
      numSelected=entries.size();
      if (entries.isEmpty()) {
        JOptionPane.showMessageDialog(frame,Localization.lang("First select the entries you want keys to be generated for."),Localization.lang("Autogenerate BibTeX key"),JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      frame.block();
      output(Localization.lang("Generating BibTeX key for") + ' ' + numSelected+ ' '+ (numSelected > 1 ? Localization.lang("entries") : Localization.lang("entry"))+ "...");
    }
    @Override public void run(){
      BibtexEntry bes;
      NamedCompound ce=new NamedCompound(Localization.lang("autogenerate keys"));
      for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
        bes=i.next();
        if (bes.getField(BibtexFields.KEY_FIELD) != null) {
          if (Globals.prefs.getBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY)) {
            i.remove();
          }
 else           if (Globals.prefs.getBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY)) {
            CheckBoxMessage cbm=new CheckBoxMessage(Localization.lang("One or more keys will be overwritten. Continue?"),Localization.lang("Disable this confirmation dialog"),false);
            int answer=JOptionPane.showConfirmDialog(frame,cbm,Localization.lang("Overwrite keys"),JOptionPane.YES_NO_OPTION);
            if (cbm.isSelected()) {
              Globals.prefs.putBoolean(JabRefPreferences.WARN_BEFORE_OVERWRITING_KEY,false);
            }
            if (answer == JOptionPane.NO_OPTION) {
              cancelled=true;
              return;
            }
            break;
          }
        }
      }
      HashMap<BibtexEntry,Object> oldvals=new HashMap<BibtexEntry,Object>();
      if (!Globals.prefs.getBoolean(JabRefPreferences.AVOID_OVERWRITING_KEY)) {
        for (        BibtexEntry entry : entries) {
          bes=entry;
          oldvals.put(bes,bes.getField(BibtexFields.KEY_FIELD));
          database.setCiteKeyForEntry(bes.getId(),null);
        }
      }
      for (      BibtexEntry entry : entries) {
        bes=entry;
        bes=LabelPatternUtil.makeLabel(metaData,database,bes);
        ce.addEdit(new UndoableKeyChange(database,bes.getId(),(String)oldvals.get(bes),bes.getField(BibtexFields.KEY_FIELD)));
      }
      ce.end();
      undoManager.addEdit(ce);
    }
    @Override public void update(){
      database.setFollowCrossrefs(true);
      if (cancelled) {
        frame.unblock();
        return;
      }
      markBaseChanged();
      numSelected=entries.size();
      for (      final BibtexEntry bibEntry : entries) {
        SwingUtilities.invokeLater(new Runnable(){
          @Override public void run(){
            final int row=mainTable.findEntry(bibEntry);
            if (row >= 0 && mainTable.getSelectedRowCount() < entries.size()) {
              mainTable.addRowSelectionInterval(row,row);
            }
          }
        }
);
      }
      output(Localization.lang("Generated BibTeX key for") + ' ' + numSelected+ ' '+ (numSelected != 1 ? Localization.lang("entries") : Localization.lang("entry")));
      frame.unblock();
    }
  }
);
  actions.put("Cleanup",cleanUpAction);
  actions.put("mergeEntries",new BaseAction(){
    @Override public void action(){
      new MergeEntriesDialog(BasePanel.this);
    }
  }
);
  actions.put("search",new BaseAction(){
    @Override public void action(){
      sidePaneManager.show("search");
      frame.searchToggle.setSelected(true);
      frame.getSearchManager().startSearch();
    }
  }
);
  actions.put("toggleSearch",new BaseAction(){
    @Override public void action(){
      sidePaneManager.toggle("search");
      boolean on=sidePaneManager.isComponentVisible("search");
      frame.searchToggle.setSelected(on);
      if (on) {
        frame.getSearchManager().startSearch();
      }
    }
  }
);
  actions.put("incSearch",new BaseAction(){
    @Override public void action(){
      sidePaneManager.show("search");
      frame.searchToggle.setSelected(true);
      frame.getSearchManager().startIncrementalSearch();
    }
  }
);
  actions.put("copyKey",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        storeCurrentEdit();
        Vector<Object> keys=new Vector<Object>();
        for (        BibtexEntry be : bes) {
          if (be.getField(BibtexFields.KEY_FIELD) != null) {
            keys.add(be.getField(BibtexFields.KEY_FIELD));
          }
        }
        if (keys.isEmpty()) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringBuilder sb=new StringBuilder((String)keys.elementAt(0));
        for (int i=1; i < keys.size(); i++) {
          sb.append(',');
          sb.append((String)keys.elementAt(i));
        }
        StringSelection ss=new StringSelection(sb.toString());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (keys.size() == bes.length) {
          output(Localization.lang(bes.length > 1 ? "Copied keys" : "Copied key") + '.');
        }
 else {
          output(Localization.lang("Warning") + ": " + (bes.length - keys.size())+ ' '+ Localization.lang("out of")+ ' '+ bes.length+ ' '+ Localization.lang("entries have undefined BibTeX key")+ '.');
        }
      }
    }
  }
);
  actions.put("copyCiteKey",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        storeCurrentEdit();
        Vector<Object> keys=new Vector<Object>();
        for (        BibtexEntry be : bes) {
          if (be.getField(BibtexFields.KEY_FIELD) != null) {
            keys.add(be.getField(BibtexFields.KEY_FIELD));
          }
        }
        if (keys.isEmpty()) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringBuilder sb=new StringBuilder((String)keys.elementAt(0));
        for (int i=1; i < keys.size(); i++) {
          sb.append(',');
          sb.append((String)keys.elementAt(i));
        }
        StringSelection ss=new StringSelection("\\cite{" + sb.toString() + '}');
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (keys.size() == bes.length) {
          output(bes.length > 1 ? Localization.lang("Copied keys") : Localization.lang("Copied key") + '.');
        }
 else {
          output(Localization.lang("Warning") + ": " + (bes.length - keys.size())+ ' '+ Localization.lang("out of")+ ' '+ bes.length+ ' '+ Localization.lang("entries have undefined BibTeX key")+ '.');
        }
      }
    }
  }
);
  actions.put("copyKeyAndTitle",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length > 0) {
        storeCurrentEdit();
        StringReader sr=new StringReader("\\bibtexkey - \\begin{title}\\format[RemoveBrackets]{\\title}\\end{title}\n");
        Layout layout;
        try {
          layout=new LayoutHelper(sr).getLayoutFromText(Globals.FORMATTER_PACKAGE);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        StringBuilder sb=new StringBuilder();
        int copied=0;
        for (        BibtexEntry be : bes) {
          if (be.getField(BibtexFields.KEY_FIELD) != null) {
            copied++;
            sb.append(layout.doLayout(be,database));
          }
        }
        if (copied == 0) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringSelection ss=new StringSelection(sb.toString());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (copied == bes.length) {
          output(Localization.lang(bes.length > 1 ? "Copied keys" : "Copied key") + '.');
        }
 else {
          output(Localization.lang("Warning") + ": " + copied+ ' '+ Localization.lang("out of")+ ' '+ bes.length+ ' '+ Localization.lang("entries have undefined BibTeX key")+ '.');
        }
      }
    }
  }
);
  actions.put("mergeDatabase",new AppendDatabaseAction(frame,this));
  actions.put("openFile",new BaseAction(){
    @Override public void action(){
      JabRefExecutorService.INSTANCE.execute(new Runnable(){
        @Override public void run(){
          BibtexEntry[] bes=mainTable.getSelectedEntries();
          String field="ps";
          if (bes != null && bes.length == 1) {
            FileListEntry entry=null;
            FileListTableModel tm=new FileListTableModel();
            tm.setContent(bes[0].getField("file"));
            for (int i=0; i < tm.getRowCount(); i++) {
              FileListEntry flEntry=tm.getEntry(i);
              if (flEntry.getType().getName().toLowerCase().equals("pdf") || flEntry.getType().getName().toLowerCase().equals("ps")) {
                entry=flEntry;
                break;
              }
            }
            if (entry != null) {
              try {
                JabRefDesktop.openExternalFileAnyFormat(metaData,entry.getLink(),entry.getType());
                output(Localization.lang("External viewer called") + '.');
              }
 catch (              IOException e) {
                output(Localization.lang("Could not open link"));
                e.printStackTrace();
              }
              return;
            }
            Object link=bes[0].getField("ps");
            if (bes[0].getField("pdf") != null) {
              link=bes[0].getField("pdf");
              field="pdf";
            }
            String filepath=null;
            if (link != null) {
              filepath=link.toString();
            }
 else {
              if (Globals.prefs.getBoolean(JabRefPreferences.RUN_AUTOMATIC_FILE_SEARCH)) {
                final Collection<BibtexEntry> entries=new ArrayList<BibtexEntry>();
                entries.add(bes[0]);
                ExternalFileType[] types=Globals.prefs.getExternalFileTypeSelection();
                ArrayList<File> dirs=new ArrayList<File>();
                if (metaData.getFileDirectory(GUIGlobals.FILE_FIELD).length > 0) {
                  String[] mdDirs=metaData.getFileDirectory(GUIGlobals.FILE_FIELD);
                  for (                  String mdDir : mdDirs) {
                    dirs.add(new File(mdDir));
                  }
                }
                Collection<String> extensions=new ArrayList<String>();
                for (                final ExternalFileType type : types) {
                  extensions.add(type.getExtension());
                }
                Map<BibtexEntry,List<File>> result;
                if (Globals.prefs.getBoolean(JabRefPreferences.USE_REG_EXP_SEARCH_KEY)) {
                  String regExp=Globals.prefs.get(JabRefPreferences.REG_EXP_SEARCH_EXPRESSION_KEY);
                  result=RegExpFileSearch.findFilesForSet(entries,extensions,dirs,regExp);
                }
 else {
                  result=Util.findAssociatedFiles(entries,extensions,dirs);
                }
                if (result.get(bes[0]) != null) {
                  List<File> res=result.get(bes[0]);
                  if (!res.isEmpty()) {
                    filepath=res.get(0).getPath();
                    int index=filepath.lastIndexOf('.');
                    if (index >= 0 && index < filepath.length() - 1) {
                      String extension=filepath.substring(index + 1);
                      ExternalFileType type=Globals.prefs.getExternalFileTypeByExt(extension);
                      if (type != null) {
                        try {
                          JabRefDesktop.openExternalFileAnyFormat(metaData,filepath,type);
                          output(Localization.lang("External viewer called") + '.');
                          return;
                        }
 catch (                        IOException ex) {
                          output(Localization.lang("Error") + ": " + ex.getMessage());
                        }
                      }
                    }
                  }
                }
              }
            }
            if (filepath != null) {
              try {
                JabRefDesktop.openExternalViewer(metaData(),filepath,field);
                output(Localization.lang("External viewer called") + '.');
              }
 catch (              IOException ex) {
                output(Localization.lang("Error") + ": " + ex.getMessage());
              }
            }
 else {
              output(Localization.lang("No pdf or ps defined, and no file matching Bibtex key found") + '.');
            }
          }
 else {
            output(Localization.lang("No entries or multiple entries selected."));
          }
        }
      }
);
    }
  }
);
  actions.put("addFileLink",new AttachFileAction(this));
  actions.put("openExternalFile",new BaseAction(){
    @Override public void action(){
      JabRefExecutorService.INSTANCE.execute(new Runnable(){
        @Override public void run(){
          BibtexEntry[] bes=mainTable.getSelectedEntries();
          String field=GUIGlobals.FILE_FIELD;
          if (bes != null && bes.length == 1) {
            Object link=bes[0].getField(field);
            if (link == null) {
              runCommand("openFile");
              return;
            }
            FileListTableModel tableModel=new FileListTableModel();
            tableModel.setContent((String)link);
            if (tableModel.getRowCount() == 0) {
              runCommand("openFile");
              return;
            }
            FileListEntry flEntry=tableModel.getEntry(0);
            ExternalFileMenuItem item=new ExternalFileMenuItem(frame(),bes[0],"",flEntry.getLink(),flEntry.getType().getIcon(),metaData(),flEntry.getType());
            item.openLink();
          }
 else {
            output(Localization.lang("No entries or multiple entries selected."));
          }
        }
      }
);
    }
  }
);
  actions.put("openFolder",new BaseAction(){
    @Override public void action(){
      JabRefExecutorService.INSTANCE.execute(new Runnable(){
        @Override public void run(){
          BibtexEntry[] bes=mainTable.getSelectedEntries();
          List<File> files=Util.getListOfLinkedFiles(bes,metaData().getFileDirectory(GUIGlobals.FILE_FIELD));
          for (          File f : files) {
            try {
              JabRefDesktop.openFolderAndSelectFile(f.getAbsolutePath());
            }
 catch (            IOException e) {
              LOGGER.info("Could not open folder",e);
            }
          }
        }
      }
);
    }
  }
);
  actions.put("openUrl",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      String field="doi";
      if (bes != null && bes.length == 1) {
        Object link=bes[0].getField("doi");
        if (bes[0].getField("url") != null) {
          link=bes[0].getField("url");
          field="url";
        }
        if (link != null) {
          try {
            JabRefDesktop.openExternalViewer(metaData(),link.toString(),field);
            output(Localization.lang("External viewer called") + '.');
          }
 catch (          IOException ex) {
            output(Localization.lang("Error") + ": " + ex.getMessage());
          }
        }
 else {
          FileListEntry entry=null;
          FileListTableModel tm=new FileListTableModel();
          tm.setContent(bes[0].getField("file"));
          for (int i=0; i < tm.getRowCount(); i++) {
            FileListEntry flEntry=tm.getEntry(i);
            if (flEntry.getType().getName().toLowerCase().equals("url") || flEntry.getType().getName().toLowerCase().equals("ps")) {
              entry=flEntry;
              break;
            }
          }
          if (entry != null) {
            try {
              JabRefDesktop.openExternalFileAnyFormat(metaData,entry.getLink(),entry.getType());
              output(Localization.lang("External viewer called") + '.');
            }
 catch (            IOException e) {
              output(Localization.lang("Could not open link"));
              e.printStackTrace();
            }
          }
 else {
            output(Localization.lang("No url defined") + '.');
          }
        }
      }
 else {
        output(Localization.lang("No entries or multiple entries selected."));
      }
    }
  }
);
  actions.put("openSpires",new BaseAction(){
    @Override public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if (bes != null && bes.length == 1) {
        Object link=null;
        if (bes[0].getField("eprint") != null) {
          link=SPIRESFetcher.constructUrlFromEprint(bes[0].getField("eprint"));
        }
 else         if (bes[0].getField("slaccitation") != null) {
          link=SPIRESFetcher.constructUrlFromSlaccitation(bes[0].getField("slaccitation"));
        }
        if (link != null) {
          try {
            JabRefDesktop.openExternalViewer(metaData(),link.toString(),"url");
            output(Localization.lang("External viewer called") + '.');
          }
 catch (          IOException ex) {
            output(Localization.lang("Error") + ": " + ex.getMessage());
          }
        }
 else {
          output(Localization.lang("No url defined") + '.');
        }
      }
 else {
        output(Localization.lang("No entries or multiple entries selected."));
      }
    }
  }
);
  actions.put("replaceAll",new BaseAction(){
    @Override public void action(){
      ReplaceStringDialog rsd=new ReplaceStringDialog(frame);
      rsd.setVisible(true);
      if (!rsd.okPressed()) {
        return;
      }
      int counter=0;
      NamedCompound ce=new NamedCompound(Localization.lang("Replace string"));
      if (!rsd.selOnly()) {
        for (        BibtexEntry entry : database.getEntries()) {
          counter+=rsd.replace(entry,ce);
        }
      }
 else {
        BibtexEntry[] bes=mainTable.getSelectedEntries();
        for (        BibtexEntry be : bes) {
          counter+=rsd.replace(be,ce);
        }
      }
      output(Localization.lang("Replaced") + ' ' + counter+ ' '+ Localization.lang(counter == 1 ? "occurence" : "occurences")+ '.');
      if (counter > 0) {
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
      }
    }
  }
);
  actions.put("dupliCheck",new BaseAction(){
    @Override public void action(){
      JabRefExecutorService.INSTANCE.execute(new DuplicateSearch(BasePanel.this));
    }
  }
);
  actions.put("plainTextImport",new BaseAction(){
    @Override public void action(){
      EntryTypeDialog etd=new EntryTypeDialog(frame);
      Util.placeDialog(etd,BasePanel.this);
      etd.setVisible(true);
      BibtexEntryType tp=etd.getChoice();
      if (tp == null) {
        return;
      }
      String id=IdGenerator.next();
      BibtexEntry bibEntry=new BibtexEntry(id,tp);
      TextInputDialog tidialog=new TextInputDialog(frame,BasePanel.this,"import",true,bibEntry);
      Util.placeDialog(tidialog,BasePanel.this);
      tidialog.setVisible(true);
      if (tidialog.okPressed()) {
        Util.setAutomaticFields(Collections.singletonList(bibEntry),false,false,false);
        insertEntry(bibEntry);
      }
    }
  }
);
  actions.put("markEntries",new MarkEntriesAction(frame,0));
  actions.put("unmarkEntries",new BaseAction(){
    @Override public void action(){
      try {
        BibtexEntry[] bes=mainTable.getSelectedEntries();
        if (bes.length == 0) {
          output(Localization.lang("No entries selected."));
          return;
        }
        NamedCompound ce=new NamedCompound(Localization.lang("Unmark entries"));
        for (        BibtexEntry be : bes) {
          EntryMarker.unmarkEntry(be,false,database,ce);
        }
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
        String outputStr;
        if (bes.length == 1) {
          outputStr=Localization.lang("Unmarked selected entry");
        }
 else {
          outputStr=Localization.lang("Unmarked all %0 selected entries",Integer.toString(bes.length));
        }
        output(outputStr);
      }
 catch (      Throwable ex) {
        ex.printStackTrace();
      }
    }
  }
);
  actions.put("unmarkAll",new BaseAction(){
    @Override public void action(){
      NamedCompound ce=new NamedCompound(Localization.lang("Unmark all"));
      for (      BibtexEntry be : database.getEntries()) {
        EntryMarker.unmarkEntry(be,false,database,ce);
      }
      ce.end();
      undoManager.addEdit(ce);
      markBaseChanged();
      output(Localization.lang("Unmarked all entries"));
    }
  }
);
  actions.put(Relevance.getInstance().getValues().get(0).getActionName(),new SpecialFieldAction(frame,Relevance.getInstance(),Relevance.getInstance().getValues().get(0).getFieldValue(),true,Localization.lang("Toggle relevance"),Localization.lang("Toggled relevance for %0 entries")));
  actions.put(Quality.getInstance().getValues().get(0).getActionName(),new SpecialFieldAction(frame,Quality.getInstance(),Quality.getInstance().getValues().get(0).getFieldValue(),true,Localization.lang("Toggle quality"),Localization.lang("Toggled quality for %0 entries")));
  actions.put(Printed.getInstance().getValues().get(0).getActionName(),new SpecialFieldAction(frame,Printed.getInstance(),Printed.getInstance().getValues().get(0).getFieldValue(),true,Localization.lang("Toggle print status"),Localization.lang("Toggled print status for %0 entries")));
  for (  SpecialFieldValue prio : Priority.getInstance().getValues()) {
    actions.put(prio.getActionName(),prio.getAction(this.frame));
  }
  for (  SpecialFieldValue rank : Rank.getInstance().getValues()) {
    actions.put(rank.getActionName(),rank.getAction(this.frame));
  }
  for (  SpecialFieldValue status : ReadStatus.getInstance().getValues()) {
    actions.put(status.getActionName(),status.getAction(this.frame));
  }
  actions.put("togglePreview",new BaseAction(){
    @Override public void action(){
      boolean enabled=!Globals.prefs.getBoolean(JabRefPreferences.PREVIEW_ENABLED);
      Globals.prefs.putBoolean(JabRefPreferences.PREVIEW_ENABLED,enabled);
      frame.setPreviewActive(enabled);
      frame.previewToggle.setSelected(enabled);
    }
  }
);
  actions.put("toggleHighlightGroupsMatchingAny",new BaseAction(){
    @Override public void action(){
      boolean enabled=!Globals.prefs.getBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ANY);
      Globals.prefs.putBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ANY,enabled);
      frame.highlightAny.setSelected(enabled);
      if (enabled) {
        frame.highlightAll.setSelected(false);
        Globals.prefs.putBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ALL,false);
      }
      groupsHighlightListener.listChanged(null);
    }
  }
);
  actions.put("toggleHighlightGroupsMatchingAll",new BaseAction(){
    @Override public void action(){
      boolean enabled=!Globals.prefs.getBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ALL);
      Globals.prefs.putBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ALL,enabled);
      frame.highlightAll.setSelected(enabled);
      if (enabled) {
        frame.highlightAny.setSelected(false);
        Globals.prefs.putBoolean(JabRefPreferences.HIGHLIGHT_GROUPS_MATCHING_ANY,false);
      }
      groupsHighlightListener.listChanged(null);
    }
  }
);
  actions.put("switchPreview",new BaseAction(){
    @Override public void action(){
      selectionListener.switchPreview();
    }
  }
);
  actions.put("manageSelectors",new BaseAction(){
    @Override public void action(){
      ContentSelectorDialog2 csd=new ContentSelectorDialog2(frame,frame,BasePanel.this,false,metaData,null);
      Util.placeDialog(csd,frame);
      csd.setVisible(true);
    }
  }
);
  actions.put("exportToClipboard",new ExportToClipboardAction(frame,database()));
  actions.put("sendAsEmail",new SendAsEMailAction(frame));
  actions.put("writeXMP",new WriteXMPAction(this));
  actions.put("abbreviateIso",new AbbreviateAction(this,true));
  actions.put("abbreviateMedline",new AbbreviateAction(this,false));
  actions.put("unabbreviate",new UnabbreviateAction(this));
  actions.put("autoSetPdf",new AutoSetExternalFileForEntries(this,"pdf"));
  actions.put("autoSetPs",new AutoSetExternalFileForEntries(this,"ps"));
  actions.put("autoSetFile",new SynchronizeFileField(this));
  actions.put("back",new BaseAction(){
    @Override public void action() throws Throwable {
      back();
    }
  }
);
  actions.put("forward",new BaseAction(){
    @Override public void action() throws Throwable {
      forward();
    }
  }
);
  actions.put("resolveDuplicateKeys",new SearchFixDuplicateLabels(this));
  actions.put("addToGroup",new GroupAddRemoveDialog(this,true,false));
  actions.put("removeFromGroup",new GroupAddRemoveDialog(this,false,false));
  actions.put("moveToGroup",new GroupAddRemoveDialog(this,true,true));
}
