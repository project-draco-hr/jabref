{
  List<String> cited=findCitedKeys();
  Map<String,BibDatabase> linkSourceBase=new HashMap<>();
  Map<BibEntry,BibDatabase> entries=findCitedEntries(databases,cited,linkSourceBase);
  XNameAccess nameAccess=getReferenceMarks();
  String[] names;
  if (style.isSortByPosition()) {
    names=sortedReferenceMarks;
  }
 else   if (style.isNumberEntries()) {
    SortedMap<BibEntry,BibDatabase> newMap=new TreeMap<>(entryComparator);
    for (    Map.Entry<BibEntry,BibDatabase> bibtexEntryBibtexDatabaseEntry : entries.entrySet()) {
      newMap.put(bibtexEntryBibtexDatabaseEntry.getKey(),bibtexEntryBibtexDatabaseEntry.getValue());
    }
    entries=newMap;
    cited.clear();
    for (    BibEntry entry : entries.keySet()) {
      cited.add(entry.getCiteKey());
    }
    names=nameAccess.getElementNames();
  }
 else {
    names=sortedReferenceMarks;
  }
  List<String> tmp=new ArrayList<>();
  for (  String name : names) {
    if (CITE_PATTERN.matcher(name).find()) {
      tmp.add(name);
    }
  }
  names=tmp.toArray(new String[tmp.size()]);
  Map<String,Integer> numbers=new HashMap<>();
  int lastNum=0;
  String[] citMarkers=new String[names.length];
  String[][] normCitMarkers=new String[names.length][];
  String[][] bibtexKeys=new String[names.length][];
  int minGroupingCount=style.getIntCitProperty("MinimumGroupingCount");
  int[] types=new int[names.length];
  for (int i=0; i < names.length; i++) {
    Matcher m=CITE_PATTERN.matcher(names[i]);
    if (m.find()) {
      String typeStr=m.group(1);
      int type=Integer.parseInt(typeStr);
      types[i]=type;
      String[] keys=m.group(2).split(",");
      bibtexKeys[i]=keys;
      BibEntry[] cEntries=new BibEntry[keys.length];
      for (int j=0; j < cEntries.length; j++) {
        BibDatabase database=linkSourceBase.get(keys[j]);
        cEntries[j]=null;
        if (database != null) {
          cEntries[j]=database.getEntryByKey(keys[j]);
        }
        if (cEntries[j] == null) {
          LOGGER.info("BibTeX key not found : '" + keys[j] + '\'');
          LOGGER.info("Problem with reference mark: '" + names[i] + '\'');
          cEntries[j]=new UndefinedBibtexEntry(keys[j]);
        }
      }
      String[] normCitMarker=new String[keys.length];
      String citationMarker;
      if (style.isBibtexKeyCiteMarkers()) {
        StringBuilder sb=new StringBuilder();
        normCitMarkers[i]=new String[keys.length];
        for (int j=0; j < keys.length; j++) {
          normCitMarkers[i][j]=cEntries[j].getCiteKey();
          sb.append(cEntries[j].getCiteKey());
          if (j < (keys.length - 1)) {
            sb.append(',');
          }
        }
        citationMarker=sb.toString();
      }
 else       if (style.isNumberEntries()) {
        if (style.isSortByPosition()) {
          List<Integer> num=new ArrayList<>(keys.length);
          for (int j=0; j < keys.length; j++) {
            if (cEntries[j] instanceof UndefinedBibtexEntry) {
              num.add(j,-1);
            }
 else {
              num.add(j,lastNum + 1);
              if (numbers.containsKey(keys[j])) {
                num.add(j,numbers.get(keys[j]));
              }
 else {
                numbers.put(keys[j],num.get(j));
                lastNum=num.get(j);
              }
            }
          }
          citationMarker=style.getNumCitationMarker(num,minGroupingCount,false);
          for (int j=0; j < keys.length; j++) {
            List<Integer> list=new ArrayList<>(1);
            list.add(num.get(j));
            normCitMarker[j]=style.getNumCitationMarker(list,minGroupingCount,false);
          }
        }
 else {
          List<Integer> num=findCitedEntryIndex(names[i],cited);
          if (num.isEmpty()) {
            throw new BibEntryNotFoundException(names[i],Localization.lang("Could not resolve BibTeX entry for citation marker '%0'.",names[i]));
          }
 else {
            citationMarker=style.getNumCitationMarker(num,minGroupingCount,false);
          }
          for (int j=0; j < keys.length; j++) {
            List<Integer> list=new ArrayList<>(1);
            list.add(num.get(j));
            normCitMarker[j]=style.getNumCitationMarker(list,minGroupingCount,false);
          }
        }
      }
 else {
        if (cEntries.length > 1) {
          if (style.getBooleanCitProperty("MultiCiteChronological")) {
            Arrays.sort(cEntries,yearAuthorTitleComparator);
          }
 else {
            Arrays.sort(cEntries,entryComparator);
          }
          for (int j=0; j < cEntries.length; j++) {
            bibtexKeys[i][j]=cEntries[j].getCiteKey();
          }
        }
        citationMarker=style.getCitationMarker(cEntries,entries.get(cEntries),type == OOBibBase.AUTHORYEAR_PAR,(String[])null,(int[])null);
        for (int j=0; j < cEntries.length; j++) {
          normCitMarker[j]=style.getCitationMarker(cEntries[j],entries.get(cEntries),true,null,-1);
        }
      }
      citMarkers[i]=citationMarker;
      normCitMarkers[i]=normCitMarker;
    }
  }
  uniquefiers.clear();
  if (!style.isBibtexKeyCiteMarkers() && !style.isNumberEntries()) {
    Map<String,List<String>> refKeys=new HashMap<>();
    Map<String,List<Integer>> refNums=new HashMap<>();
    for (int i=0; i < citMarkers.length; i++) {
      String[] markers=normCitMarkers[i];
      for (int j=0; j < markers.length; j++) {
        String marker=markers[j];
        if (refKeys.containsKey(marker)) {
          if (!refKeys.get(marker).contains(bibtexKeys[i][j])) {
            refKeys.get(marker).add(bibtexKeys[i][j]);
            refNums.get(marker).add(i);
          }
        }
 else {
          List<String> l=new ArrayList<>(1);
          l.add(bibtexKeys[i][j]);
          refKeys.put(marker,l);
          List<Integer> l2=new ArrayList<>(1);
          l2.add(i);
          refNums.put(marker,l2);
        }
      }
    }
    for (    Map.Entry<String,List<String>> stringListEntry : refKeys.entrySet()) {
      List<String> keys=stringListEntry.getValue();
      if (keys.size() > 1) {
        int uniq='a';
        for (        String key : keys) {
          uniquefiers.put(key,String.valueOf((char)uniq));
          uniq++;
        }
      }
    }
    int maxAuthorsFirst=style.getIntCitProperty("MaxAuthorsFirst");
    Set<String> seenBefore=new HashSet<>();
    for (int j=0; j < bibtexKeys.length; j++) {
      boolean needsChange=false;
      int[] firstLimAuthors=new int[bibtexKeys[j].length];
      String[] uniquif=new String[bibtexKeys[j].length];
      BibEntry[] cEntries=new BibEntry[bibtexKeys[j].length];
      for (int k=0; k < bibtexKeys[j].length; k++) {
        firstLimAuthors[k]=-1;
        if (maxAuthorsFirst > 0) {
          if (!seenBefore.contains(bibtexKeys[j][k])) {
            firstLimAuthors[k]=maxAuthorsFirst;
          }
          seenBefore.add(bibtexKeys[j][k]);
        }
        String uniq=uniquefiers.get(bibtexKeys[j][k]);
        if ((uniq != null) && (uniq.length() >= 0)) {
          needsChange=true;
          BibDatabase database=linkSourceBase.get(bibtexKeys[j][k]);
          if (database != null) {
            cEntries[k]=database.getEntryByKey(bibtexKeys[j][k]);
          }
          uniquif[k]=uniq;
        }
 else         if (firstLimAuthors[k] > 0) {
          needsChange=true;
          BibDatabase database=linkSourceBase.get(bibtexKeys[j][k]);
          if (database != null) {
            cEntries[k]=database.getEntryByKey(bibtexKeys[j][k]);
          }
          uniquif[k]="";
        }
 else {
          BibDatabase database=linkSourceBase.get(bibtexKeys[j][k]);
          if (database != null) {
            cEntries[k]=database.getEntryByKey(bibtexKeys[j][k]);
          }
          uniquif[k]="";
        }
      }
      if (needsChange) {
        citMarkers[j]=style.getCitationMarker(cEntries,entries.get(cEntries),types[j] == OOBibBase.AUTHORYEAR_PAR,uniquif,firstLimAuthors);
      }
    }
  }
  boolean hadBibSection=getBookmarkRange(OOBibBase.BIB_SECTION_NAME) != null;
  boolean mustTestCharFormat=style.isFormatCitations();
  for (int i=0; i < names.length; i++) {
    Object o=nameAccess.getByName(names[i]);
    XTextContent bm=UnoRuntime.queryInterface(XTextContent.class,o);
    XTextCursor cursor=bm.getAnchor().getText().createTextCursorByRange(bm.getAnchor());
    if (mustTestCharFormat) {
      mustTestCharFormat=false;
      XPropertySet xCursorProps=UnoRuntime.queryInterface(XPropertySet.class,cursor);
      String charStyle=style.getCitationCharacterFormat();
      try {
        xCursorProps.setPropertyValue("CharStyleName",charStyle);
      }
 catch (      UnknownPropertyException|PropertyVetoException|IllegalArgumentException|WrappedTargetException ex) {
        throw new UndefinedCharacterFormatException(charStyle);
      }
    }
    text.removeTextContent(bm);
    insertReferenceMark(names[i],citMarkers[i],cursor,types[i] != OOBibBase.INVISIBLE_CIT,style);
    if (hadBibSection && (getBookmarkRange(OOBibBase.BIB_SECTION_NAME) == null)) {
      cursor.collapseToEnd();
      OOUtil.insertParagraphBreak(text,cursor);
      insertBookMark(OOBibBase.BIB_SECTION_NAME,cursor);
    }
  }
  ArrayList<String> unresolvedKeys=new ArrayList<>();
  for (  BibEntry entry : entries.keySet()) {
    if (entry instanceof UndefinedBibtexEntry) {
      String key=((UndefinedBibtexEntry)entry).getKey();
      if (!unresolvedKeys.contains(key)) {
        unresolvedKeys.add(key);
      }
    }
  }
  return unresolvedKeys;
}
