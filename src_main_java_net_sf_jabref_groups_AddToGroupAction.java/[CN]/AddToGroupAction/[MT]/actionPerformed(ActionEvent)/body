{
  final BibEntry[] entries=mPanel.getSelectedEntries();
  final Vector<GroupTreeNode> removeGroupsNodes=new Vector<>();
  if (m_move) {
    Enumeration<GroupTreeNode> e=((GroupTreeNode)mNode.getRoot()).preorderEnumeration();
    for (    GroupTreeNode node : Collections.list(e)) {
      if (!node.getGroup().supportsRemove()) {
        continue;
      }
      for (      BibEntry entry : entries) {
        if (node.getGroup().contains(entry)) {
          removeGroupsNodes.add(node);
        }
      }
    }
    AbstractGroup[] groups=new AbstractGroup[removeGroupsNodes.size() + 1];
    for (int i=0; i < removeGroupsNodes.size(); ++i) {
      groups[i]=removeGroupsNodes.elementAt(i).getGroup();
    }
    groups[groups.length - 1]=mNode.getGroup();
    if (!Util.warnAssignmentSideEffects(groups,entries,mPanel.getDatabase(),mPanel.frame())) {
      return;
    }
  }
 else {
    if (!Util.warnAssignmentSideEffects(new AbstractGroup[]{mNode.getGroup()},entries,mPanel.getDatabase(),mPanel.frame())) {
      return;
    }
  }
  mPanel.storeCurrentEdit();
  NamedCompound undoAll=new NamedCompound(Localization.lang("change assignment of entries"));
  if (m_move) {
    for (int i=0; i < removeGroupsNodes.size(); ++i) {
      GroupTreeNode node=removeGroupsNodes.elementAt(i);
      if (node.getGroup().containsAny(entries)) {
        undoAll.addEdit(node.removeFromGroup(entries));
      }
    }
    AbstractUndoableEdit undoAdd=mNode.addToGroup(entries);
    if (undoAdd != null) {
      undoAll.addEdit(undoAdd);
    }
  }
 else {
    AbstractUndoableEdit undoAdd=mNode.addToGroup(entries);
    if (undoAdd == null) {
      return;
    }
    undoAll.addEdit(undoAdd);
  }
  undoAll.end();
  mPanel.undoManager.addEdit(undoAll);
  mPanel.markBaseChanged();
  mPanel.updateEntryEditorIfShowing();
  mPanel.getGroupSelector().valueChanged(null);
}
