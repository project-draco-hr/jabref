{
  ArrayList<BibtexEntry> bibitems=new ArrayList<>();
  StringBuilder sb=new StringBuilder();
  BufferedReader in=new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
  String ENDOFRECORD="__EOREOR__";
  String str;
  boolean first=true;
  while ((str=in.readLine()) != null) {
    str=str.trim();
    if (str.indexOf("%0") == 0) {
      if (first) {
        first=false;
      }
 else {
        sb.append(ENDOFRECORD);
      }
      sb.append(str);
    }
 else {
      sb.append(str);
    }
    sb.append("\n");
  }
  String[] entries=sb.toString().split(ENDOFRECORD);
  HashMap<String,String> hm=new HashMap<>();
  String author;
  String Type;
  String editor;
  String artnum;
  for (  String entry : entries) {
    hm.clear();
    author="";
    Type="";
    editor="";
    artnum="";
    boolean IsEditedBook=false;
    String[] fields=entry.trim().substring(1).split("\n%");
    for (    String field : fields) {
      if (field.length() < 3) {
        continue;
      }
      String prefix=field.substring(0,1);
      String val=field.substring(2);
switch (prefix) {
case "A":
        if (author.equals("")) {
          author=val;
        }
 else {
          author+=" and " + val;
        }
      break;
case "E":
    if (editor.equals("")) {
      editor=val;
    }
 else {
      editor+=" and " + val;
    }
  break;
case "T":
hm.put("title",val);
break;
case "0":
if (val.indexOf("Journal") == 0) {
Type="article";
}
 else if (val.indexOf("Book Section") == 0) {
Type="incollection";
}
 else if (val.indexOf("Book") == 0) {
Type="book";
}
 else if (val.indexOf("Edited Book") == 0) {
Type="book";
IsEditedBook=true;
}
 else if (val.indexOf("Conference") == 0) {
Type="inproceedings";
}
 else if (val.indexOf("Report") == 0) {
Type="techreport";
}
 else if (val.indexOf("Review") == 0) {
Type="article";
}
 else if (val.indexOf("Thesis") == 0) {
Type="phdthesis";
}
 else {
Type="misc";
}
break;
case "7":
hm.put("edition",val);
break;
case "C":
hm.put("address",val);
break;
case "D":
hm.put("year",val);
break;
case "8":
hm.put("date",val);
break;
case "J":
if (hm.get("journal") == null) {
hm.put("journal",val);
}
break;
case "B":
switch (Type) {
case "article":
hm.put("journal",val);
break;
case "book":
case "inbook":
hm.put("series",val);
break;
default :
hm.put("booktitle",val);
break;
}
break;
case "I":
if (Type.equals("phdthesis")) {
hm.put("school",val);
}
 else {
hm.put("publisher",val);
}
break;
case "P":
hm.put("pages",val.replaceAll("([0-9]) *- *([0-9])","$1--$2"));
break;
case "V":
hm.put("volume",val);
break;
case "N":
hm.put("number",val);
break;
case "U":
hm.put("url",val);
break;
case "R":
String doi=val;
if (doi.startsWith("doi:")) {
doi=doi.substring(4);
}
hm.put("doi",doi);
break;
case "O":
if (val.startsWith("Artn")) {
String[] tokens=val.split("\\s");
artnum=tokens[1];
}
 else {
hm.put("note",val);
}
break;
case "K":
hm.put("keywords",val);
break;
case "X":
hm.put("abstract",val);
break;
case "9":
if (val.indexOf("Ph.D.") == 0) {
Type="phdthesis";
}
if (val.indexOf("Masters") == 0) {
Type="mastersthesis";
}
break;
case "F":
hm.put(BibtexFields.KEY_FIELD,Util.checkLegalKey(val));
break;
}
}
if (IsEditedBook && editor.equals("")) {
editor=author;
author="";
}
if (!author.equals("")) {
hm.put("author",fixAuthor(author));
}
if (!editor.equals("")) {
hm.put("editor",fixAuthor(editor));
}
if ((hm.get("pages") == null || hm.get("pages").equals("-")) && !artnum.equals("")) {
hm.put("pages",artnum);
}
BibtexEntry b=new BibtexEntry(BibtexFields.DEFAULT_BIBTEXENTRY_ID,Globals.getEntryType(Type));
b.setField(hm);
if (!b.getAllFields().isEmpty()) {
bibitems.add(b);
}
}
return bibitems;
}
