{
  String urlencodedCitation=null;
  try {
    urlencodedCitation=URLEncoder.encode(text,"UTF-8");
  }
 catch (  UnsupportedEncodingException e) {
  }
  String data="citation=" + urlencodedCitation;
  URL url;
  URLConnection conn;
  try {
    url=new URL("http://freecite.library.brown.edu/citations/create");
    conn=url.openConnection();
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
    return null;
  }
catch (  IOException e) {
    e.printStackTrace();
    return null;
  }
  try {
    conn.setRequestProperty("accept","text/xml");
    conn.setDoOutput(true);
    OutputStreamWriter writer=new OutputStreamWriter(conn.getOutputStream());
    writer.write(data);
    writer.flush();
  }
 catch (  IOException e) {
    status.showMessage(Globals.lang("Unable to connect to freecite online service."));
    return null;
  }
catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
  List<BibtexEntry> res=new ArrayList<BibtexEntry>();
  XMLInputFactory factory=XMLInputFactory.newInstance();
  try {
    XMLStreamReader parser=factory.createXMLStreamReader(conn.getInputStream());
    while (parser.hasNext()) {
      if ((parser.getEventType() == XMLStreamConstants.START_ELEMENT) && (parser.getLocalName().equals("citation"))) {
        parser.nextTag();
        StringBuilder noteSB=new StringBuilder();
        BibtexEntry e=new BibtexEntry();
        BibtexEntryType type=BibtexEntryType.INPROCEEDINGS;
        while (!((parser.getEventType() == XMLStreamConstants.END_ELEMENT) && parser.getLocalName().equals("citation"))) {
          if (parser.getEventType() == XMLStreamConstants.START_ELEMENT) {
            String ln=parser.getLocalName();
            if (ln.equals("authors")) {
              StringBuilder sb=new StringBuilder();
              parser.nextTag();
              while (parser.getEventType() == XMLStreamConstants.START_ELEMENT) {
                assert(parser.getLocalName().equals("author"));
                String author=parser.getElementText();
                if (sb.length() == 0) {
                  sb.append(author);
                }
 else {
                  sb.append(" and ");
                  sb.append(author);
                }
                assert(parser.getEventType() == XMLStreamConstants.END_ELEMENT);
                assert(parser.getLocalName().equals("author"));
                parser.nextTag();
              }
              e.setField("author",sb.toString());
            }
 else             if (ln.equals("journal")) {
              type=BibtexEntryType.ARTICLE;
              e.setField(ln,parser.getElementText());
            }
 else             if (ln.equals("tech")) {
              type=BibtexEntryType.TECHREPORT;
              e.setField("number",parser.getElementText());
            }
 else             if (ln.equals("doi") || ln.equals("institution") || ln.equals("location")|| ln.equals("number")|| ln.equals("note")|| ln.equals("title")|| ln.equals("pages")|| ln.equals("publisher")|| ln.equals("volume")|| ln.equals("year")) {
              e.setField(ln,parser.getElementText());
            }
 else             if (ln.equals("booktitle")) {
              String booktitle=parser.getElementText();
              if (booktitle.startsWith("In ")) {
                booktitle=booktitle.substring(3);
              }
              e.setField("booktitle",booktitle);
            }
 else             if (ln.equals("raw_string")) {
            }
 else {
              noteSB.append(ln);
              noteSB.append(":");
              noteSB.append(parser.getElementText());
              noteSB.append(Globals.NEWLINE);
            }
          }
          parser.next();
        }
        if (noteSB.length() > 0) {
          String note=e.getField("note");
          if (note != null) {
            note=note.concat(Globals.NEWLINE).concat(noteSB.toString());
          }
 else {
            note=noteSB.toString();
          }
          e.setField("note",note);
        }
        e.setType(type);
        e=LabelPatternUtil.makeLabel(JabRef.jrf.basePanel().metaData(),JabRef.jrf.basePanel().database(),e);
        res.add(e);
      }
      parser.next();
    }
    parser.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return null;
  }
  return res;
}
