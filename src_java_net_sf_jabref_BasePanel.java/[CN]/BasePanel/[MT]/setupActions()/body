{
  saveAction=new SaveDatabaseAction(this);
  actions.put("undo",undoAction);
  actions.put("redo",redoAction);
  actions.put("focusTable",new BaseAction(){
    public void action() throws Throwable {
      new FocusRequester(mainTable);
    }
  }
);
  actions.put("edit",new BaseAction(){
    public void action(){
      selectionListener.editSignalled();
    }
  }
);
  actions.put("test",new FindFullTextAction(this));
  actions.put("save",saveAction);
  actions.put("saveAs",new BaseAction(){
    public void action() throws Throwable {
      saveAction.saveAs();
    }
  }
);
  actions.put("saveSelectedAs",new BaseAction(){
    public void action() throws Throwable {
      String chosenFile=FileDialogs.getNewFile(frame,new File(Globals.prefs.get("workingDirectory")),".bib",JFileChooser.SAVE_DIALOG,false);
      if (chosenFile != null) {
        File expFile=new File(chosenFile);
        if (!expFile.exists() || (JOptionPane.showConfirmDialog(frame,"'" + expFile.getName() + "' "+ Globals.lang("exists. Overwrite file?"),Globals.lang("Save database"),JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION)) {
          saveDatabase(expFile,true,Globals.prefs.get("defaultEncoding"));
          frame.getFileHistory().newFile(expFile.getPath());
          frame.output(Globals.lang("Saved selected to") + " '" + expFile.getPath()+ "'.");
        }
      }
    }
  }
);
  actions.put("copy",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        TransferableBibtexEntry trbe=new TransferableBibtexEntry(bes);
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(trbe,BasePanel.this);
        output(Globals.lang("Copied") + " " + (bes.length > 1 ? bes.length + " " + Globals.lang("entries") : "1 " + Globals.lang("entry") + "."));
      }
 else {
        int[] rows=mainTable.getSelectedRows(), cols=mainTable.getSelectedColumns();
        if ((cols.length == 1) && (rows.length == 1)) {
          Object o=mainTable.getValueAt(rows[0],cols[0]);
          if (o != null) {
            StringSelection ss=new StringSelection(o.toString());
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
            output(Globals.lang("Copied cell contents") + ".");
          }
        }
      }
    }
  }
);
  actions.put("cut",new BaseAction(){
    public void action() throws Throwable {
      runCommand("copy");
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        NamedCompound ce=new NamedCompound(Globals.lang(bes.length > 1 ? "cut entries" : "cut entry"));
        for (int i=0; i < bes.length; i++) {
          database.removeEntry(bes[i].getId());
          ensureNotShowing(bes[i]);
          ce.addEdit(new UndoableRemoveEntry(database,bes[i],BasePanel.this));
        }
        frame.output(Globals.lang("Cut_pr") + " " + (bes.length > 1 ? bes.length + " " + Globals.lang("entries") : Globals.lang("entry"))+ ".");
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
      }
    }
  }
);
  actions.put("delete",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        boolean goOn=showDeleteConfirmationDialog(bes.length);
        if (!goOn) {
          return;
        }
 else {
          NamedCompound ce=new NamedCompound(Globals.lang(bes.length > 1 ? "delete entries" : "delete entry"));
          for (int i=0; i < bes.length; i++) {
            database.removeEntry(bes[i].getId());
            ensureNotShowing(bes[i]);
            ce.addEdit(new UndoableRemoveEntry(database,bes[i],BasePanel.this));
          }
          markBaseChanged();
          frame.output(Globals.lang("Deleted") + " " + (bes.length > 1 ? bes.length + " " + Globals.lang("entries") : Globals.lang("entry"))+ ".");
          ce.end();
          undoManager.addEdit(ce);
        }
      }
    }
  }
);
  actions.put("paste",new BaseAction(){
    public void action(){
      Transferable content=Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null);
      if (content != null) {
        BibtexEntry[] bes=null;
        if (content.isDataFlavorSupported(TransferableBibtexEntry.entryFlavor)) {
          try {
            bes=(BibtexEntry[])(content.getTransferData(TransferableBibtexEntry.entryFlavor));
          }
 catch (          UnsupportedFlavorException ex) {
            ex.printStackTrace();
          }
catch (          IOException ex) {
            ex.printStackTrace();
          }
        }
 else         if (content.isDataFlavorSupported(DataFlavor.stringFlavor)) {
          try {
            BibtexParser bp=new BibtexParser(new java.io.StringReader((String)(content.getTransferData(DataFlavor.stringFlavor))));
            BibtexDatabase db=bp.parse().getDatabase();
            Util.pr("Parsed " + db.getEntryCount() + " entries from clipboard text");
            if (db.getEntryCount() > 0) {
              bes=db.getEntries().toArray(new BibtexEntry[db.getEntryCount()]);
            }
          }
 catch (          UnsupportedFlavorException ex) {
            ex.printStackTrace();
          }
catch (          Throwable ex) {
            ex.printStackTrace();
          }
        }
        if ((bes != null) && (bes.length > 0)) {
          NamedCompound ce=new NamedCompound(Globals.lang(bes.length > 1 ? "paste entries" : "paste entry"));
          BibtexEntry firstBE=null;
          for (int i=0; i < bes.length; i++) {
            try {
              BibtexEntry be=(BibtexEntry)(bes[i].clone());
              if (firstBE == null)               firstBE=be;
              Util.setAutomaticFields(be,Globals.prefs.getBoolean("overwriteOwner"),Globals.prefs.getBoolean("overwriteTimeStamp"));
              be.setId(Util.createNeutralId());
              database.insertEntry(be);
              addToSelectedGroup(be);
              ce.addEdit(new UndoableInsertEntry(database,be,BasePanel.this));
            }
 catch (            KeyCollisionException ex) {
              Util.pr("KeyCollisionException... this shouldn't happen.");
            }
          }
          ce.end();
          undoManager.addEdit(ce);
          output(Globals.lang("Pasted") + " " + (bes.length > 1 ? bes.length + " " + Globals.lang("entries") : "1 " + Globals.lang("entry"))+ ".");
          markBaseChanged();
          if (Globals.prefs.getBoolean("autoOpenForm")) {
            selectionListener.editSignalled(firstBE);
          }
          highlightEntry(firstBE);
        }
      }
    }
  }
);
  actions.put("selectAll",new BaseAction(){
    public void action(){
      mainTable.selectAll();
    }
  }
);
  actions.put("editPreamble",new BaseAction(){
    public void action(){
      if (preambleEditor == null) {
        PreambleEditor form=new PreambleEditor(frame,BasePanel.this,database,Globals.prefs);
        Util.placeDialog(form,frame);
        form.setVisible(true);
        preambleEditor=form;
      }
 else {
        preambleEditor.setVisible(true);
      }
    }
  }
);
  actions.put("editStrings",new BaseAction(){
    public void action(){
      if (stringDialog == null) {
        StringDialog form=new StringDialog(frame,BasePanel.this,database,Globals.prefs);
        Util.placeDialog(form,frame);
        form.setVisible(true);
        stringDialog=form;
      }
 else {
        stringDialog.setVisible(true);
      }
    }
  }
);
  actions.put("toggleGroups",new BaseAction(){
    public void action(){
      sidePaneManager.toggle("groups");
      frame.groupToggle.setSelected(sidePaneManager.isComponentVisible("groups"));
    }
  }
);
  actions.put("dbConnect",new DbConnectAction(this));
  actions.put("dbExport",new AbstractWorker(){
    String errorMessage=null;
    boolean connectToDB=false;
    public void init(){
      DBStrings dbs=metaData.getDBStrings();
      if (!dbs.isConfigValid()) {
        if (!dbs.isInitialized()) {
          dbs.initialize();
        }
        DBConnectDialog dbd=new DBConnectDialog(frame(),dbs);
        Util.placeDialog(dbd,BasePanel.this);
        dbd.setVisible(true);
        connectToDB=dbd.getConnectToDB();
        if (connectToDB) {
          dbs=dbd.getDBStrings();
          metaData.setDBStrings(dbs);
          dbd.dispose();
        }
      }
 else {
        connectToDB=true;
      }
    }
    public void run(){
      if (connectToDB) {
        DBStrings dbs=metaData.getDBStrings();
        try {
          frame.output(Globals.lang("Attempting SQL export..."));
          DBExporterAndImporterFactory factory=new DBExporterAndImporterFactory();
          DBExporter exporter=factory.getExporter(dbs.getServerType());
          exporter.exportDatabaseToDBMS(database,metaData,null,dbs,frame);
          dbs.isConfigValid(true);
        }
 catch (        Exception ex) {
          String preamble="Could not export to SQL database for the following reason:";
          errorMessage=SQLUtil.getExceptionMessage(ex);
          ex.printStackTrace();
          dbs.isConfigValid(false);
          JOptionPane.showMessageDialog(frame,Globals.lang(preamble) + "\n" + errorMessage,Globals.lang("Export to SQL database"),JOptionPane.ERROR_MESSAGE);
        }
        metaData.setDBStrings(dbs);
      }
    }
    public void update(){
      if (errorMessage == null) {
        if (connectToDB) {
          frame.output(Globals.lang("%0 export successful"));
        }
      }
 else {
        String preamble="Could not export to SQL database for the following reason:";
        frame.output(Globals.lang(preamble) + "  " + errorMessage);
        JOptionPane.showMessageDialog(frame,Globals.lang(preamble) + "\n" + errorMessage,Globals.lang("Export to SQL database"),JOptionPane.ERROR_MESSAGE);
        errorMessage=null;
      }
    }
  }
);
  actions.put("makeKey",new AbstractWorker(){
    List<BibtexEntry> entries;
    int numSelected;
    boolean cancelled=false;
    public void init(){
      entries=new ArrayList<BibtexEntry>(Arrays.asList(getSelectedEntries()));
      numSelected=entries.size();
      if (entries.size() == 0) {
        JOptionPane.showMessageDialog(frame,Globals.lang("First select the entries you want keys to be generated for."),Globals.lang("Autogenerate BibTeX key"),JOptionPane.INFORMATION_MESSAGE);
        return;
      }
      frame.block();
      output(Globals.lang("Generating BibTeX key for") + " " + numSelected+ " "+ (numSelected > 1 ? Globals.lang("entries") : Globals.lang("entry"))+ "...");
    }
    public void run(){
      database.setFollowCrossrefs(false);
      BibtexEntry bes=null;
      NamedCompound ce=new NamedCompound(Globals.lang("autogenerate keys"));
      loop:       for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
        bes=i.next();
        if (bes.getField(BibtexFields.KEY_FIELD) != null) {
          if (Globals.prefs.getBoolean("avoidOverwritingKey"))           i.remove();
 else           if (Globals.prefs.getBoolean("warnBeforeOverwritingKey")) {
            CheckBoxMessage cbm=new CheckBoxMessage(Globals.lang("One or more keys will be overwritten. Continue?"),Globals.lang("Disable this confirmation dialog"),false);
            int answer=JOptionPane.showConfirmDialog(frame,cbm,Globals.lang("Overwrite keys"),JOptionPane.YES_NO_OPTION);
            if (cbm.isSelected())             Globals.prefs.putBoolean("warnBeforeOverwritingKey",false);
            if (answer == JOptionPane.NO_OPTION) {
              cancelled=true;
              return;
            }
            break loop;
          }
        }
      }
      HashMap<BibtexEntry,Object> oldvals=new HashMap<BibtexEntry,Object>();
      if (!Globals.prefs.getBoolean("avoidOverwritingKey"))       for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
        bes=i.next();
        oldvals.put(bes,bes.getField(BibtexFields.KEY_FIELD));
        database.setCiteKeyForEntry(bes.getId(),null);
      }
      for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
        bes=i.next();
        bes=LabelPatternUtil.makeLabel(Globals.prefs.getKeyPattern(),database,bes);
        ce.addEdit(new UndoableKeyChange(database,bes.getId(),(String)oldvals.get(bes),bes.getField(BibtexFields.KEY_FIELD)));
      }
      ce.end();
      undoManager.addEdit(ce);
    }
    public void update(){
      database.setFollowCrossrefs(true);
      if (cancelled) {
        frame.unblock();
        return;
      }
      markBaseChanged();
      numSelected=entries.size();
      for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
        final BibtexEntry bibEntry=i.next();
        SwingUtilities.invokeLater(new Runnable(){
          public void run(){
            final int row=mainTable.findEntry(bibEntry);
            if (row >= 0 && mainTable.getSelectedRowCount() < entries.size())             mainTable.addRowSelectionInterval(row,row);
          }
        }
);
      }
      output(Globals.lang("Generated BibTeX key for") + " " + numSelected+ " "+ (numSelected != 1 ? Globals.lang("entries") : Globals.lang("entry")));
      frame.unblock();
    }
  }
);
  actions.put("search",new BaseAction(){
    public void action(){
      sidePaneManager.show("search");
      frame.searchToggle.setSelected(true);
      if (true)       frame.getSearchManager().startSearch();
    }
  }
);
  actions.put("toggleSearch",new BaseAction(){
    public void action(){
      sidePaneManager.toggle("search");
      boolean on=sidePaneManager.isComponentVisible("search");
      frame.searchToggle.setSelected(on);
      if (on)       frame.getSearchManager().startSearch();
    }
  }
);
  actions.put("incSearch",new BaseAction(){
    public void action(){
      sidePaneManager.show("search");
      frame.searchToggle.setSelected(true);
      frame.getSearchManager().startIncrementalSearch();
    }
  }
);
  actions.put("copyKey",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        storeCurrentEdit();
        Vector<Object> keys=new Vector<Object>();
        for (int i=0; i < bes.length; i++)         if (bes[i].getField(BibtexFields.KEY_FIELD) != null)         keys.add(bes[i].getField(BibtexFields.KEY_FIELD));
        if (keys.size() == 0) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringBuffer sb=new StringBuffer((String)keys.elementAt(0));
        for (int i=1; i < keys.size(); i++) {
          sb.append(',');
          sb.append((String)keys.elementAt(i));
        }
        StringSelection ss=new StringSelection(sb.toString());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (keys.size() == bes.length)         output(Globals.lang((bes.length > 1) ? "Copied keys" : "Copied key") + ".");
 else         output(Globals.lang("Warning") + ": " + (bes.length - keys.size())+ " "+ Globals.lang("out of")+ " "+ bes.length+ " "+ Globals.lang("entries have undefined BibTeX key")+ ".");
      }
    }
  }
);
  actions.put("copyCiteKey",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        storeCurrentEdit();
        Vector<Object> keys=new Vector<Object>();
        for (int i=0; i < bes.length; i++)         if (bes[i].getField(BibtexFields.KEY_FIELD) != null)         keys.add(bes[i].getField(BibtexFields.KEY_FIELD));
        if (keys.size() == 0) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringBuffer sb=new StringBuffer((String)keys.elementAt(0));
        for (int i=1; i < keys.size(); i++) {
          sb.append(',');
          sb.append((String)keys.elementAt(i));
        }
        StringSelection ss=new StringSelection("\\cite{" + sb.toString() + "}");
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (keys.size() == bes.length)         output(Globals.lang((bes.length > 1) ? "Copied keys" : "Copied key") + ".");
 else         output(Globals.lang("Warning") + ": " + (bes.length - keys.size())+ " "+ Globals.lang("out of")+ " "+ bes.length+ " "+ Globals.lang("entries have undefined BibTeX key")+ ".");
      }
    }
  }
);
  actions.put("copyKeyAndTitle",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length > 0)) {
        storeCurrentEdit();
        StringReader sr=new StringReader("\\bibtexkey - \\begin{title}\\format[RemoveBrackets]{\\title}\\end{title}\n");
        Layout layout;
        try {
          layout=new LayoutHelper(sr).getLayoutFromText(Globals.FORMATTER_PACKAGE);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return;
        }
        StringBuffer sb=new StringBuffer();
        int copied=0;
        for (int i=0; i < bes.length; i++)         if (bes[i].getField(BibtexFields.KEY_FIELD) != null) {
          copied++;
          sb.append(layout.doLayout(bes[i],database));
        }
        if (copied == 0) {
          output("None of the selected entries have BibTeX keys.");
          return;
        }
        StringSelection ss=new StringSelection(sb.toString());
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(ss,BasePanel.this);
        if (copied == bes.length)         output(Globals.lang((bes.length > 1) ? "Copied keys" : "Copied key") + ".");
 else         output(Globals.lang("Warning") + ": " + (copied)+ " "+ Globals.lang("out of")+ " "+ bes.length+ " "+ Globals.lang("entries have undefined BibTeX key")+ ".");
      }
    }
  }
);
  actions.put("mergeDatabase",new AppendDatabaseAction(frame,this));
  actions.put("openFile",new BaseAction(){
    public void action(){
      (new Thread(){
        public void run(){
          BibtexEntry[] bes=mainTable.getSelectedEntries();
          String field="ps";
          if ((bes != null) && (bes.length == 1)) {
            FileListEntry entry=null;
            FileListTableModel tm=new FileListTableModel();
            tm.setContent(bes[0].getField("file"));
            for (int i=0; i < tm.getRowCount(); i++) {
              FileListEntry flEntry=tm.getEntry(i);
              if (flEntry.getType().getName().toLowerCase().equals("pdf") || flEntry.getType().getName().toLowerCase().equals("ps")) {
                entry=flEntry;
                break;
              }
            }
            if (entry != null) {
              try {
                Util.openExternalFileAnyFormat(metaData,entry.getLink(),entry.getType());
                output(Globals.lang("External viewer called") + ".");
              }
 catch (              IOException e) {
                output(Globals.lang("Could not open link"));
                e.printStackTrace();
              }
              return;
            }
            Object link=bes[0].getField("ps");
            if (bes[0].getField("pdf") != null) {
              link=bes[0].getField("pdf");
              field="pdf";
            }
            String filepath=null;
            if (link != null) {
              filepath=link.toString();
            }
 else {
              if (Globals.prefs.getBoolean("runAutomaticFileSearch")) {
                final Collection<BibtexEntry> entries=new ArrayList<BibtexEntry>();
                entries.add(bes[0]);
                ExternalFileType[] types=Globals.prefs.getExternalFileTypeSelection();
                ArrayList<File> dirs=new ArrayList<File>();
                if (metaData.getFileDirectory(GUIGlobals.FILE_FIELD).length > 0) {
                  String[] mdDirs=metaData.getFileDirectory(GUIGlobals.FILE_FIELD);
                  for (int i=0; i < mdDirs.length; i++) {
                    dirs.add(new File(mdDirs[i]));
                  }
                }
                Collection<String> extensions=new ArrayList<String>();
                for (int i=0; i < types.length; i++) {
                  final ExternalFileType type=types[i];
                  extensions.add(type.getExtension());
                }
                Map<BibtexEntry,List<File>> result;
                if (Globals.prefs.getBoolean(JabRefPreferences.USE_REG_EXP_SEARCH_KEY)) {
                  String regExp=Globals.prefs.get(JabRefPreferences.REG_EXP_SEARCH_EXPRESSION_KEY);
                  result=RegExpFileSearch.findFilesForSet(entries,extensions,dirs,regExp);
                }
 else                 result=Util.findAssociatedFiles(entries,extensions,dirs);
                if (result.get(bes[0]) != null) {
                  List<File> res=result.get(bes[0]);
                  if (res.size() > 0) {
                    filepath=res.get(0).getPath();
                    int index=filepath.lastIndexOf('.');
                    if ((index >= 0) && (index < filepath.length() - 1)) {
                      String extension=filepath.substring(index + 1);
                      ExternalFileType type=Globals.prefs.getExternalFileTypeByExt(extension);
                      if (type != null) {
                        try {
                          Util.openExternalFileAnyFormat(metaData,filepath,type);
                          output(Globals.lang("External viewer called") + ".");
                          return;
                        }
 catch (                        IOException ex) {
                          output(Globals.lang("Error") + ": " + ex.getMessage());
                        }
                      }
                    }
                  }
                }
              }
            }
            if (filepath != null) {
              try {
                Util.openExternalViewer(metaData(),filepath,field);
                output(Globals.lang("External viewer called") + ".");
              }
 catch (              IOException ex) {
                output(Globals.lang("Error") + ": " + ex.getMessage());
              }
            }
 else             output(Globals.lang("No pdf or ps defined, and no file matching Bibtex key found") + ".");
          }
 else           output(Globals.lang("No entries or multiple entries selected."));
        }
      }
).start();
    }
  }
);
  actions.put("openExternalFile",new BaseAction(){
    public void action(){
      (new Thread(){
        public void run(){
          BibtexEntry[] bes=mainTable.getSelectedEntries();
          String field=GUIGlobals.FILE_FIELD;
          if ((bes != null) && (bes.length == 1)) {
            Object link=bes[0].getField(field);
            if (link == null) {
              runCommand("openFile");
              return;
            }
            FileListTableModel tableModel=new FileListTableModel();
            tableModel.setContent((String)link);
            if (tableModel.getRowCount() == 0) {
              runCommand("openFile");
              return;
            }
            FileListEntry flEntry=tableModel.getEntry(0);
            ExternalFileMenuItem item=new ExternalFileMenuItem(frame(),bes[0],"",flEntry.getLink(),flEntry.getType().getIcon(),metaData(),flEntry.getType());
            item.openLink();
          }
 else           output(Globals.lang("No entries or multiple entries selected."));
        }
      }
).start();
    }
  }
);
  actions.put("openUrl",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      String field="doi";
      if ((bes != null) && (bes.length == 1)) {
        Object link=bes[0].getField("doi");
        if (bes[0].getField("url") != null) {
          link=bes[0].getField("url");
          field="url";
        }
        if (link != null) {
          try {
            Util.openExternalViewer(metaData(),link.toString(),field);
            output(Globals.lang("External viewer called") + ".");
          }
 catch (          IOException ex) {
            output(Globals.lang("Error") + ": " + ex.getMessage());
          }
        }
 else {
          FileListEntry entry=null;
          FileListTableModel tm=new FileListTableModel();
          tm.setContent(bes[0].getField("file"));
          for (int i=0; i < tm.getRowCount(); i++) {
            FileListEntry flEntry=tm.getEntry(i);
            if (flEntry.getType().getName().toLowerCase().equals("url") || flEntry.getType().getName().toLowerCase().equals("ps")) {
              entry=flEntry;
              break;
            }
          }
          if (entry != null) {
            try {
              Util.openExternalFileAnyFormat(metaData,entry.getLink(),entry.getType());
              output(Globals.lang("External viewer called") + ".");
            }
 catch (            IOException e) {
              output(Globals.lang("Could not open link"));
              e.printStackTrace();
            }
            return;
          }
 else           output(Globals.lang("No url defined") + ".");
        }
      }
 else       output(Globals.lang("No entries or multiple entries selected."));
    }
  }
);
  actions.put("openSpires",new BaseAction(){
    public void action(){
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      if ((bes != null) && (bes.length == 1)) {
        Object link=null;
        if (bes[0].getField("eprint") != null)         link=SPIRESFetcher.constructUrlFromEprint(bes[0].getField("eprint").toString());
 else         if (bes[0].getField("slaccitation") != null)         link=SPIRESFetcher.constructUrlFromSlaccitation(bes[0].getField("slaccitation").toString());
        if (link != null) {
          try {
            Util.openExternalViewer(metaData(),link.toString(),"url");
            output(Globals.lang("External viewer called") + ".");
          }
 catch (          IOException ex) {
            output(Globals.lang("Error") + ": " + ex.getMessage());
          }
        }
 else         output(Globals.lang("No url defined") + ".");
      }
 else       output(Globals.lang("No entries or multiple entries selected."));
    }
  }
);
  actions.put("replaceAll",new BaseAction(){
    public void action(){
      ReplaceStringDialog rsd=new ReplaceStringDialog(frame);
      rsd.setVisible(true);
      if (!rsd.okPressed())       return;
      int counter=0;
      NamedCompound ce=new NamedCompound(Globals.lang("Replace string"));
      if (!rsd.selOnly()) {
        for (        BibtexEntry entry : database.getEntries()) {
          counter+=rsd.replace(entry,ce);
        }
      }
 else {
        BibtexEntry[] bes=mainTable.getSelectedEntries();
        for (int i=0; i < bes.length; i++)         counter+=rsd.replace(bes[i],ce);
      }
      output(Globals.lang("Replaced") + " " + counter+ " "+ Globals.lang(counter == 1 ? "occurence" : "occurences")+ ".");
      if (counter > 0) {
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
      }
    }
  }
);
  actions.put("dupliCheck",new BaseAction(){
    public void action(){
      DuplicateSearch ds=new DuplicateSearch(BasePanel.this);
      ds.start();
    }
  }
);
  actions.put("plainTextImport",new BaseAction(){
    public void action(){
      EntryTypeDialog etd=new EntryTypeDialog(frame);
      Util.placeDialog(etd,BasePanel.this);
      etd.setVisible(true);
      BibtexEntryType tp=etd.getChoice();
      if (tp == null)       return;
      String id=Util.createNeutralId();
      BibtexEntry bibEntry=new BibtexEntry(id,tp);
      TextInputDialog tidialog=new TextInputDialog(frame,BasePanel.this,"import",true,bibEntry);
      Util.placeDialog(tidialog,BasePanel.this);
      tidialog.setVisible(true);
      if (tidialog.okPressed()) {
        Util.setAutomaticFields(Arrays.asList(new BibtexEntry[]{bibEntry}),false,false,false);
        insertEntry(bibEntry);
      }
    }
  }
);
  actions.put("markEntries",new AbstractWorker(){
    private int besLength=-1;
    public void run(){
      NamedCompound ce=new NamedCompound(Globals.lang("Mark entries"));
      BibtexEntry[] bes=mainTable.getSelectedEntries();
      besLength=bes.length;
      for (int i=0; i < bes.length; i++) {
        Util.markEntry(bes[i],1,true,ce);
      }
      ce.end();
      undoManager.addEdit(ce);
    }
    public void update(){
      markBaseChanged();
      output(Globals.lang("Marked selected") + " " + Globals.lang(besLength > 0 ? "entry" : "entries"));
    }
  }
);
  actions.put("unmarkEntries",new BaseAction(){
    public void action(){
      try {
        NamedCompound ce=new NamedCompound(Globals.lang("Unmark entries"));
        BibtexEntry[] bes=mainTable.getSelectedEntries();
        if (bes == null)         return;
        for (int i=0; i < bes.length; i++) {
          Util.unmarkEntry(bes[i],false,database,ce);
        }
        ce.end();
        undoManager.addEdit(ce);
        markBaseChanged();
        output(Globals.lang("Unmarked selected") + " " + Globals.lang(bes.length > 0 ? "entry" : "entries"));
      }
 catch (      Throwable ex) {
        ex.printStackTrace();
      }
    }
  }
);
  actions.put("unmarkAll",new BaseAction(){
    public void action(){
      NamedCompound ce=new NamedCompound(Globals.lang("Unmark all"));
      for (      BibtexEntry be : database.getEntries()) {
        Util.unmarkEntry(be,false,database,ce);
      }
      ce.end();
      undoManager.addEdit(ce);
      markBaseChanged();
    }
  }
);
  actions.put("togglePreview",new BaseAction(){
    public void action(){
      boolean enabled=!Globals.prefs.getBoolean("previewEnabled");
      Globals.prefs.putBoolean("previewEnabled",enabled);
      frame.setPreviewActive(enabled);
      frame.previewToggle.setSelected(enabled);
    }
  }
);
  actions.put("toggleHighlightGroupsMatchingAny",new BaseAction(){
    public void action(){
      boolean enabled=!Globals.prefs.getBoolean("highlightGroupsMatchingAny");
      Globals.prefs.putBoolean("highlightGroupsMatchingAny",enabled);
      frame.highlightAny.setSelected(enabled);
      if (enabled) {
        frame.highlightAll.setSelected(false);
        Globals.prefs.putBoolean("highlightGroupsMatchingAll",false);
      }
      groupsHighlightListener.listChanged(null);
    }
  }
);
  actions.put("toggleHighlightGroupsMatchingAll",new BaseAction(){
    public void action(){
      boolean enabled=!Globals.prefs.getBoolean("highlightGroupsMatchingAll");
      Globals.prefs.putBoolean("highlightGroupsMatchingAll",enabled);
      frame.highlightAll.setSelected(enabled);
      if (enabled) {
        frame.highlightAny.setSelected(false);
        Globals.prefs.putBoolean("highlightGroupsMatchingAny",false);
      }
      groupsHighlightListener.listChanged(null);
    }
  }
);
  actions.put("switchPreview",new BaseAction(){
    public void action(){
      selectionListener.switchPreview();
    }
  }
);
  actions.put("manageSelectors",new BaseAction(){
    public void action(){
      ContentSelectorDialog2 csd=new ContentSelectorDialog2(frame,frame,BasePanel.this,false,metaData,null);
      Util.placeDialog(csd,frame);
      csd.setVisible(true);
    }
  }
);
  actions.put("exportToClipboard",new ExportToClipboardAction(frame,database()));
  actions.put("sendAsEmail",new SendAsEMailAction(frame));
  actions.put("writeXMP",new WriteXMPAction(this));
  actions.put("abbreviateIso",new AbbreviateAction(this,true));
  actions.put("abbreviateMedline",new AbbreviateAction(this,false));
  actions.put("unabbreviate",new UnabbreviateAction(this));
  actions.put("autoSetPdf",new AutoSetExternalFileForEntries(this,"pdf"));
  actions.put("autoSetPs",new AutoSetExternalFileForEntries(this,"ps"));
  actions.put("autoSetFile",new SynchronizeFileField(this));
  actions.put("upgradeLinks",new UpgradeExternalLinks(this));
  actions.put("back",new BaseAction(){
    public void action() throws Throwable {
      back();
    }
  }
);
  actions.put("forward",new BaseAction(){
    public void action() throws Throwable {
      forward();
    }
  }
);
  actions.put("resolveDuplicateKeys",new SearchFixDuplicateLabels(this));
}
