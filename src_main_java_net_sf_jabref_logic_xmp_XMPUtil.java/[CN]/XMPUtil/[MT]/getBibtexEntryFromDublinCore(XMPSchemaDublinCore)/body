{
  BibEntry entry=new BibEntry();
  List<String> contributors=dcSchema.getContributors();
  if (contributors != null) {
    Iterator<String> it=contributors.iterator();
    StringBuffer sb=null;
    while (it.hasNext()) {
      if (sb == null) {
        sb=new StringBuffer();
      }
 else {
        sb.append(" and ");
      }
      sb.append(it.next());
    }
    if (sb != null) {
      entry.setField("editor",sb.toString());
    }
  }
  List<String> creators=dcSchema.getCreators();
  if (creators != null) {
    Iterator<String> it=creators.iterator();
    StringBuffer sb=null;
    while (it.hasNext()) {
      if (sb == null) {
        sb=new StringBuffer();
      }
 else {
        sb.append(" and ");
      }
      sb.append(it.next());
    }
    if (sb != null) {
      entry.setField("author",sb.toString());
    }
  }
  List<String> dates=dcSchema.getSequenceList("dc:date");
  if ((dates != null) && !dates.isEmpty()) {
    String date=dates.get(0).trim();
    Calendar c=null;
    try {
      c=DateConverter.toCalendar(date);
    }
 catch (    IOException ignored) {
    }
    if (c != null) {
      entry.setField("year",String.valueOf(c.get(Calendar.YEAR)));
      if (date.length() > 4) {
        entry.setField("month",MonthUtil.getMonthByIndex(c.get(Calendar.MONTH)).bibtexFormat);
      }
    }
  }
  String s=dcSchema.getDescription();
  if (s != null) {
    entry.setField("abstract",s);
  }
  s=dcSchema.getIdentifier();
  if (s != null) {
    entry.setField("doi",s);
  }
  List<String> publishers=dcSchema.getPublishers();
  if (publishers != null) {
    Iterator<String> it=dcSchema.getPublishers().iterator();
    StringBuffer sb=null;
    while (it.hasNext()) {
      if (sb == null) {
        sb=new StringBuffer();
      }
 else {
        sb.append(" and ");
      }
      sb.append(it.next());
    }
    if (sb != null) {
      entry.setField("publishers",sb.toString());
    }
  }
  List<String> relationships=dcSchema.getRelationships();
  if (relationships != null) {
    for (    String r : relationships) {
      if (r.startsWith("bibtex/")) {
        r=r.substring("bibtex/".length());
        int i=r.indexOf('/');
        if (i != -1) {
          entry.setField(r.substring(0,i),r.substring(i + 1));
        }
      }
    }
  }
  s=dcSchema.getRights();
  if (s != null) {
    entry.setField("rights",s);
  }
  s=dcSchema.getSource();
  if (s != null) {
    entry.setField("source",s);
  }
  List<String> subjects=dcSchema.getSubjects();
  if (subjects != null) {
    Iterator<String> it=subjects.iterator();
    StringBuffer sb=null;
    while (it.hasNext()) {
      if (sb == null) {
        sb=new StringBuffer();
      }
 else {
        sb.append(',');
      }
      sb.append(it.next());
    }
    if (sb != null) {
      entry.setField("keywords",sb.toString());
    }
  }
  s=dcSchema.getTitle();
  if (s != null) {
    entry.setField("title",s);
  }
  List<String> l=dcSchema.getTypes();
  if ((l != null) && !l.isEmpty()) {
    s=l.get(0);
    if (s != null) {
      entry.setType(s);
    }
  }
  return entry.getFieldNames().isEmpty() ? Optional.empty() : Optional.of(entry);
}
