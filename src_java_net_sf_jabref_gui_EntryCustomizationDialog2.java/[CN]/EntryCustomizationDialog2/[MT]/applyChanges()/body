{
  valueChanged(new ListSelectionEvent(new JList(),0,0,false));
  List<String> types=typeComp.getFields();
  for (Iterator<String> i=reqLists.keySet().iterator(); i.hasNext(); ) {
    String typeName=i.next();
    if (!types.contains(typeName))     continue;
    List<String> reqFields=reqLists.get(typeName);
    List<String> optFields=optLists.get(typeName);
    List<String> opt2Fields=opt2Lists.get(typeName);
    String[] reqStr=new String[reqFields.size()];
    reqStr=reqFields.toArray(reqStr);
    String[] optStr=new String[optFields.size()];
    optStr=optFields.toArray(optStr);
    String[] opt2Str;
    if (opt2Fields != null)     opt2Str=opt2Fields.toArray(new String[opt2Fields.size()]);
 else     opt2Str=new String[0];
    boolean changesMade=true;
    if (defaulted.contains(typeName)) {
      String nm=Util.nCase(typeName);
      BibtexEntryType.removeType(nm);
      updateTypesForEntries(nm);
      continue;
    }
    BibtexEntryType oldType=BibtexEntryType.getType(typeName);
    if (oldType != null) {
      String[] oldReq=oldType.getRequiredFields(), oldOpt=oldType.getOptionalFields();
      if (biblatexMode) {
        String[] priOpt=oldType.getPrimaryOptionalFields();
        ArrayList<String> secOpt=new ArrayList<String>();
        for (int j=0; j < oldOpt.length; j++) {
          boolean inPri=false;
          for (int k=0; k < priOpt.length; k++) {
            if (priOpt[k].equals(oldOpt[j])) {
              inPri=true;
              break;
            }
          }
          if (!inPri)           secOpt.add(oldOpt[j]);
        }
        String[] secOptArray=secOpt.toArray(new String[secOpt.size()]);
        if (equalArrays(oldReq,reqStr) && equalArrays(oldOpt,optStr) && equalArrays(secOptArray,opt2Str))         changesMade=false;
      }
 else       if (equalArrays(oldReq,reqStr) && equalArrays(oldOpt,optStr))       changesMade=false;
    }
    if (changesMade) {
      CustomEntryType typ=biblatexMode ? new CustomEntryType(Util.nCase(typeName),reqStr,optStr,opt2Str) : new CustomEntryType(Util.nCase(typeName),reqStr,optStr);
      BibtexEntryType.ALL_TYPES.put(typeName.toLowerCase(),typ);
      updateTypesForEntries(typ.getName());
    }
  }
  Set<Object> toRemove=new HashSet<Object>();
  for (Iterator<String> i=BibtexEntryType.ALL_TYPES.keySet().iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (!types.contains(o)) {
      toRemove.add(o);
    }
  }
  if (toRemove.size() > 0) {
    for (Iterator<Object> i=toRemove.iterator(); i.hasNext(); )     typeDeletion((String)i.next());
  }
  updateTables();
}
