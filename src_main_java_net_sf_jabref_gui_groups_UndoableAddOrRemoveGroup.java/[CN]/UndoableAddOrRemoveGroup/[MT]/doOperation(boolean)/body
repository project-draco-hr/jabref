{
  GroupTreeNode cursor=m_groupsRootHandle.getNode();
  final int childIndex=m_pathToNode.get(m_pathToNode.size() - 1);
  for (int i=0; i < (m_pathToNode.size() - 1); ++i) {
    cursor=cursor.getChildAt(m_pathToNode.get(i));
  }
  if (undo) {
switch (m_editType) {
case ADD_NODE:
      cursor.remove(childIndex);
    break;
case REMOVE_NODE_KEEP_CHILDREN:
  GroupTreeNode newNode=m_subtreeBackup.deepCopy();
for (int i=childIndex; i < (childIndex + m_subtreeRootChildCount); ++i) {
  newNode.add(cursor.getChildAt(childIndex));
}
cursor.insert(newNode,childIndex);
break;
case REMOVE_NODE_AND_CHILDREN:
cursor.insert(m_subtreeBackup.deepCopy(),childIndex);
break;
default :
break;
}
}
 else {
switch (m_editType) {
case ADD_NODE:
cursor.insert(m_subtreeBackup.deepCopy(),childIndex);
break;
case REMOVE_NODE_KEEP_CHILDREN:
GroupTreeNode removedNode=cursor.getChildAt(childIndex);
cursor.remove(childIndex);
while (removedNode.getChildCount() > 0) {
cursor.insert(removedNode.getFirstChild(),childIndex);
}
break;
case REMOVE_NODE_AND_CHILDREN:
cursor.remove(childIndex);
break;
default :
break;
}
}
if (mRevalidate) {
m_groupSelector.revalidateGroups();
}
}
