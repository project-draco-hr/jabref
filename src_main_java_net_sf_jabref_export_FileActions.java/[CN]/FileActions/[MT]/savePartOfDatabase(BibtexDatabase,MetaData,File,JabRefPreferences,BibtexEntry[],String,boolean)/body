{
  TreeMap<String,BibtexEntryType> types=new TreeMap<String,BibtexEntryType>();
  BibtexEntry be=null;
  boolean backup=prefs.getBoolean("backup");
  SaveSession session;
  try {
    session=new SaveSession(file,encoding,backup);
  }
 catch (  IOException e) {
    throw new SaveException(e.getMessage());
  }
  try {
    VerifyingWriter fw=session.getWriter();
    if (!writePlainBibtex) {
      writeBibFileHeader(fw,encoding);
    }
    writePreamble(fw,database.getPreamble());
    writeStrings(fw,database);
    List<Comparator<BibtexEntry>> comparators=getSaveComparators(true,metaData);
    BasicEventList<BibtexEntry> entryList=new BasicEventList<BibtexEntry>();
    SortedList<BibtexEntry> sorter=new SortedList<BibtexEntry>(entryList,new FieldComparatorStack<BibtexEntry>(comparators));
    if ((bes != null) && (bes.length > 0)) {
      Collections.addAll(sorter,bes);
    }
    FieldFormatter ff=new LatexFieldFormatter();
    for (    BibtexEntry aSorter : sorter) {
      be=(aSorter);
      BibtexEntryType tp=be.getType();
      if (BibtexEntryType.getStandardType(tp.getName()) == null) {
        types.put(tp.getName(),tp);
      }
      be.write(fw,ff,true);
      fw.write(Globals.NEWLINE);
    }
    if (!writePlainBibtex && metaData != null) {
      metaData.writeMetaData(fw);
    }
    if (types.size() > 0) {
      for (      String s : types.keySet()) {
        CustomEntryType tp=(CustomEntryType)types.get(s);
        tp.save(fw);
        fw.write(Globals.NEWLINE);
      }
    }
    fw.close();
  }
 catch (  Throwable ex) {
    session.cancel();
    throw new SaveException(ex.getMessage(),be);
  }
  return session;
}
