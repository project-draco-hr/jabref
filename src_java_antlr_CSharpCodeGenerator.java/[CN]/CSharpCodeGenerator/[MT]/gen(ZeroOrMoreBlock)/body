{
  if (DEBUG_CODE_GENERATOR)   System.out.println("gen*(" + blk + ")");
  println("{    // ( ... )*");
  tabs++;
  genBlockPreamble(blk);
  String label;
  if (blk.getLabel() != null) {
    label=blk.getLabel();
  }
 else {
    label="_loop" + blk.ID;
  }
  println("for (;;)");
  println("{");
  tabs++;
  genBlockInitAction(blk);
  String saveCurrentASTResult=currentASTResult;
  if (blk.getLabel() != null) {
    currentASTResult=blk.getLabel();
  }
  boolean ok=grammar.theLLkAnalyzer.deterministic(blk);
  boolean generateNonGreedyExitPath=false;
  int nonGreedyExitDepth=grammar.maxk;
  if (!blk.greedy && blk.exitLookaheadDepth <= grammar.maxk && blk.exitCache[blk.exitLookaheadDepth].containsEpsilon()) {
    generateNonGreedyExitPath=true;
    nonGreedyExitDepth=blk.exitLookaheadDepth;
  }
 else   if (!blk.greedy && blk.exitLookaheadDepth == LLkGrammarAnalyzer.NONDETERMINISTIC) {
    generateNonGreedyExitPath=true;
  }
  if (generateNonGreedyExitPath) {
    if (DEBUG_CODE_GENERATOR) {
      System.out.println("nongreedy (...)* loop; exit depth is " + blk.exitLookaheadDepth);
    }
    String predictExit=getLookaheadTestExpression(blk.exitCache,nonGreedyExitDepth);
    println("// nongreedy exit test");
    println("if (" + predictExit + ") goto "+ label+ "_breakloop;");
  }
  CSharpBlockFinishingInfo howToFinish=genCommonBlock(blk,false);
  genBlockFinish(howToFinish,"goto " + label + "_breakloop;");
  tabs--;
  println("}");
  _print(label + "_breakloop:");
  println(";");
  tabs--;
  println("}    // ( ... )*");
  currentASTResult=saveCurrentASTResult;
}
