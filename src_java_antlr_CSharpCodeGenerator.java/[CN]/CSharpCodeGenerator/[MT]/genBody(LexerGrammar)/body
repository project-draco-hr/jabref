{
  setupOutput(grammar.getClassName());
  genAST=false;
  saveText=true;
  tabs=0;
  genHeader();
  println(behavior.getHeaderAction(""));
  if (nameSpace != null)   nameSpace.emitDeclarations(currentOutput);
  tabs++;
  println("// Generate header specific to lexer CSharp file");
  println("using System;");
  println("using Stream                          = System.IO.Stream;");
  println("using TextReader                      = System.IO.TextReader;");
  println("using Hashtable                       = System.Collections.Hashtable;");
  println("using Comparer                        = System.Collections.Comparer;");
  if (!(g.caseSensitiveLiterals)) {
    println("using CaseInsensitiveHashCodeProvider = System.Collections.CaseInsensitiveHashCodeProvider;");
    println("using CaseInsensitiveComparer         = System.Collections.CaseInsensitiveComparer;");
  }
  println("");
  println("using TokenStreamException            = antlr.TokenStreamException;");
  println("using TokenStreamIOException          = antlr.TokenStreamIOException;");
  println("using TokenStreamRecognitionException = antlr.TokenStreamRecognitionException;");
  println("using CharStreamException             = antlr.CharStreamException;");
  println("using CharStreamIOException           = antlr.CharStreamIOException;");
  println("using ANTLRException                  = antlr.ANTLRException;");
  println("using CharScanner                     = antlr.CharScanner;");
  println("using InputBuffer                     = antlr.InputBuffer;");
  println("using ByteBuffer                      = antlr.ByteBuffer;");
  println("using CharBuffer                      = antlr.CharBuffer;");
  println("using Token                           = antlr.Token;");
  println("using CommonToken                     = antlr.CommonToken;");
  println("using SemanticException               = antlr.SemanticException;");
  println("using RecognitionException            = antlr.RecognitionException;");
  println("using NoViableAltForCharException     = antlr.NoViableAltForCharException;");
  println("using MismatchedCharException         = antlr.MismatchedCharException;");
  println("using TokenStream                     = antlr.TokenStream;");
  println("using LexerSharedInputState           = antlr.LexerSharedInputState;");
  println("using BitSet                          = antlr.collections.impl.BitSet;");
  println(grammar.preambleAction.getText());
  String sup=null;
  if (grammar.superClass != null) {
    sup=grammar.superClass;
  }
 else {
    sup="antlr." + grammar.getSuperClass();
  }
  if (grammar.comment != null) {
    _println(grammar.comment);
  }
  Token tprefix=(Token)grammar.options.get("classHeaderPrefix");
  if (tprefix == null) {
    print("public ");
  }
 else {
    String p=StringUtils.stripFrontBack(tprefix.getText(),"\"","\"");
    if (p == null) {
      print("public ");
    }
 else {
      print(p + " ");
    }
  }
  print("class " + grammar.getClassName() + " : "+ sup);
  println(", TokenStream");
  Token tsuffix=(Token)grammar.options.get("classHeaderSuffix");
  if (tsuffix != null) {
    String suffix=StringUtils.stripFrontBack(tsuffix.getText(),"\"","\"");
    if (suffix != null) {
      print(", " + suffix);
    }
  }
  println(" {");
  tabs++;
  genTokenDefinitions(grammar.tokenManager);
  print(processActionForSpecialSymbols(grammar.classMemberAction.getText(),grammar.classMemberAction.getLine(),currentRule,null));
  println("public " + grammar.getClassName() + "(Stream ins) : this(new ByteBuffer(ins))");
  println("{");
  println("}");
  println("");
  println("public " + grammar.getClassName() + "(TextReader r) : this(new CharBuffer(r))");
  println("{");
  println("}");
  println("");
  print("public " + grammar.getClassName() + "(InputBuffer ib)");
  if (grammar.debuggingOutput)   println(" : this(new LexerSharedInputState(new antlr.debug.DebuggingInputBuffer(ib)))");
 else   println(" : this(new LexerSharedInputState(ib))");
  println("{");
  println("}");
  println("");
  println("public " + grammar.getClassName() + "(LexerSharedInputState state) : base(state)");
  println("{");
  tabs++;
  println("initialize();");
  tabs--;
  println("}");
  println("private void initialize()");
  println("{");
  tabs++;
  if (grammar.debuggingOutput) {
    println("ruleNames  = _ruleNames;");
    println("semPredNames = _semPredNames;");
    println("setupDebugging();");
  }
  println("caseSensitiveLiterals = " + g.caseSensitiveLiterals + ";");
  println("setCaseSensitive(" + g.caseSensitive + ");");
  if (g.caseSensitiveLiterals)   println("literals = new Hashtable(100, (float) 0.4, null, Comparer.Default);");
 else   println("literals = new Hashtable(100, (float) 0.4, CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);");
  Enumeration keys=grammar.tokenManager.getTokenSymbolKeys();
  while (keys.hasMoreElements()) {
    String key=(String)keys.nextElement();
    if (key.charAt(0) != '"') {
      continue;
    }
    TokenSymbol sym=grammar.tokenManager.getTokenSymbol(key);
    if (sym instanceof StringLiteralSymbol) {
      StringLiteralSymbol s=(StringLiteralSymbol)sym;
      println("literals.Add(" + s.getId() + ", "+ s.getTokenType()+ ");");
    }
  }
  Enumeration ids;
  tabs--;
  println("}");
  if (grammar.debuggingOutput) {
    println("private const string[] _ruleNames = {");
    ids=grammar.rules.elements();
    int ruleNum=0;
    while (ids.hasMoreElements()) {
      GrammarSymbol sym=(GrammarSymbol)ids.nextElement();
      if (sym instanceof RuleSymbol)       println("  \"" + ((RuleSymbol)sym).getId() + "\",");
    }
    println("};");
  }
  genNextToken();
  ids=grammar.rules.elements();
  int ruleNum=0;
  while (ids.hasMoreElements()) {
    RuleSymbol sym=(RuleSymbol)ids.nextElement();
    if (!sym.getId().equals("mnextToken")) {
      genRule(sym,false,ruleNum++,grammar.tokenManager);
    }
    exitIfError();
  }
  if (grammar.debuggingOutput)   genSemPredMap();
  genBitsets(bitsetsUsed,((LexerGrammar)grammar).charVocabulary.size());
  println("");
  tabs--;
  println("}");
  tabs--;
  if (nameSpace != null)   nameSpace.emitClosures(currentOutput);
  currentOutput.close();
  currentOutput=null;
}
