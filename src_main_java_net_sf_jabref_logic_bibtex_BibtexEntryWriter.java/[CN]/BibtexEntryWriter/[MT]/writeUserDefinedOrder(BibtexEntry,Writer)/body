{
  out.write('@' + entry.getType().getName() + '{');
  String str=StringUtil.shaveString(entry.getField(BibtexEntry.KEY_FIELD));
  out.write((str == null ? "" : str) + ',' + Globals.NEWLINE);
  HashMap<String,String> written=new HashMap<String,String>();
  written.put(BibtexEntry.KEY_FIELD,null);
  boolean hasWritten=false;
  String[] s=entry.getUserDefinedFields();
  if (s != null) {
    for (    String value : s) {
      if (!written.containsKey(value)) {
        hasWritten=hasWritten | writeField(entry,out,value,hasWritten,false);
        written.put(value,null);
      }
    }
  }
  boolean first;
  boolean previous;
  previous=false;
  TreeSet<String> remainingFields=new TreeSet<String>();
  for (  String key : entry.getAllFields()) {
    boolean writeIt=write ? BibtexFields.isWriteableField(key) : BibtexFields.isDisplayableField(key);
    if (!written.containsKey(key) && writeIt) {
      remainingFields.add(key);
    }
  }
  first=previous;
  for (  String field : remainingFields) {
    hasWritten=hasWritten | writeField(entry,out,field,hasWritten,hasWritten && first);
    first=false;
  }
  out.write((hasWritten ? Globals.NEWLINE : "") + '}' + Globals.NEWLINE);
}
