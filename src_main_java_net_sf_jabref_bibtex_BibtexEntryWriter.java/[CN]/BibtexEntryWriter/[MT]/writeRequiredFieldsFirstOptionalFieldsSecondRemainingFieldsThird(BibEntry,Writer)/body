{
  out.write('@' + entry.getType().getName() + '{');
  HashSet<String> writtenFields=new HashSet<>();
  writeKeyField(entry,out);
  writtenFields.add(BibEntry.KEY_FIELD);
  boolean hasWritten=writeField(entry,out,"title",false);
  writtenFields.add("title");
  if (entry.getRequiredFieldsFlat() != null) {
    List<String> requiredFields=getRequiredFieldsSorted(entry);
    for (    String value : requiredFields) {
      if (!writtenFields.contains(value)) {
        hasWritten=hasWritten | writeField(entry,out,value,hasWritten);
        writtenFields.add(value);
      }
    }
  }
  if (entry.getOptionalFields() != null) {
    List<String> optionalFields=getOptionalFieldsSorted(entry);
    for (    String value : optionalFields) {
      if (!writtenFields.contains(value)) {
        hasWritten=hasWritten | writeField(entry,out,value,hasWritten);
        writtenFields.add(value);
      }
    }
  }
  TreeSet<String> remainingFields=new TreeSet<>();
  for (  String key : entry.getFieldNames()) {
    boolean writeIt=write ? BibtexFields.isWriteableField(key) : BibtexFields.isDisplayableField(key);
    if (!writtenFields.contains(key) && writeIt) {
      remainingFields.add(key);
    }
  }
  for (  String field : remainingFields) {
    hasWritten=hasWritten | writeField(entry,out,field,hasWritten);
  }
  out.write((hasWritten ? Globals.NEWLINE : "") + '}');
}
