{
  BibtexDatabase database=new BibtexDatabase();
  ParserResult directParserResult=null;
  boolean anythingUseful=false;
  for (  Pair<String,ParserResult> importResult : imports) {
    if (importResult == null)     continue;
    if (importResult.p.equals(ImportFormatReader.BIBTEX_FORMAT)) {
      ParserResult pr=importResult.v;
      anythingUseful=anythingUseful || ((pr.getDatabase().getEntryCount() > 0) || (pr.getDatabase().getStringCount() > 0));
      if (directParserResult == null) {
        directParserResult=pr;
      }
      for (      BibtexEntry entry : pr.getDatabase().getEntries()) {
        database.insertEntry(entry);
      }
      for (      BibtexString bs : pr.getDatabase().getStringValues()) {
        try {
          database.addString((BibtexString)bs.clone());
        }
 catch (        KeyCollisionException e) {
        }
      }
    }
 else {
      ParserResult pr=importResult.v;
      Collection<BibtexEntry> entries=pr.getDatabase().getEntries();
      anythingUseful=anythingUseful | (entries.size() > 0);
      Util.setAutomaticFields(entries,Globals.prefs.getBoolean("overwriteOwner"),Globals.prefs.getBoolean("overwriteTimeStamp"),!openInNew && Globals.prefs.getBoolean("markImportedEntries"));
      for (      BibtexEntry entry : entries) {
        database.insertEntry(entry);
      }
    }
  }
  if (!anythingUseful)   return null;
  if ((imports.size() == 1) && (directParserResult != null)) {
    return directParserResult;
  }
 else {
    ParserResult pr=new ParserResult(database,new HashMap<String,String>(),new HashMap<String,BibtexEntryType>());
    return pr;
  }
}
