{
  if (e.getSource() instanceof FieldTextArea) {
    String toSet=null;
    FieldEditor fe=(FieldEditor)e.getSource();
    boolean set;
    if (fe.getText().length() > 0)     toSet=fe.getText();
    if (toSet == null) {
      if (entry.getField(fe.getFieldName()) == null)       set=false;
 else       set=true;
    }
 else {
      if ((entry.getField(fe.getFieldName()) != null) && toSet.equals(entry.getField(fe.getFieldName()).toString()))       set=false;
 else       set=true;
    }
    if (set)     try {
      if (toSet != null)       (new LatexFieldFormatter()).format(toSet,GUIGlobals.isStandardField(fe.getFieldName()));
      Object oldValue=entry.getField(fe.getFieldName());
      if (toSet != null)       entry.setField(fe.getFieldName(),toSet);
 else       entry.clearField(fe.getFieldName());
      if ((toSet != null) && (toSet.length() > 0)) {
        fe.setBackground(GUIGlobals.validFieldBackground);
      }
 else {
        fe.setBackground(GUIGlobals.validFieldBackground);
      }
      panel.undoManager.addEdit(new UndoableFieldChange(entry,fe.getFieldName(),oldValue,toSet));
      updateSource();
      panel.refreshTable();
      panel.markBaseChanged();
    }
 catch (    IllegalArgumentException ex) {
      JOptionPane.showMessageDialog(frame,"Error: " + ex.getMessage(),Globals.lang("Error setting field"),JOptionPane.ERROR_MESSAGE);
      fe.setBackground(GUIGlobals.invalidFieldBackground);
    }
 else {
      fe.setBackground(GUIGlobals.validFieldBackground);
    }
  }
 else   if (e.getSource() instanceof FieldTextField) {
    FieldTextField fe=(FieldTextField)e.getSource();
    String oldValue=entry.getCiteKey(), newValue=fe.getText();
    if (newValue.equals(""))     newValue=null;
    if (((oldValue == null) && (newValue == null)) || ((oldValue != null) && (newValue != null) && oldValue.equals(newValue)))     return;
    boolean isDuplicate=panel.database.setCiteKeyForEntry(entry.getId(),newValue);
    if (newValue != null) {
      if (isDuplicate) {
        panel.output(Globals.lang("Warning") + ": " + Globals.lang("duplicate BibTeX key."));
        if (prefs.getBoolean("dialogWarningForDuplicateKey")) {
          CheckBoxMessage jcb=new CheckBoxMessage(Globals.lang("Warning") + ": " + Globals.lang("duplicate BibTeX key."),Globals.lang("Disable this warning dialog"),false);
          JOptionPane.showMessageDialog(frame,jcb,Globals.lang("Warning"),JOptionPane.WARNING_MESSAGE);
          if (jcb.isSelected())           prefs.putBoolean("dialogWarningForDuplicateKey",false);
        }
      }
 else       panel.output(Globals.lang("BibTeX key is unique."));
    }
    panel.undoManager.addEdit(new UndoableKeyChange(panel.database,entry.getId(),oldValue,newValue));
    if ((newValue != null) && (newValue.length() > 0)) {
      fe.setBackground(GUIGlobals.validFieldBackground);
    }
 else {
      fe.setBackground(GUIGlobals.validFieldBackground);
    }
    panel.refreshTable();
    panel.markBaseChanged();
  }
 else   if ((source.isEditable()) && (!source.getText().equals(lastSourceStringAccepted))) {
    BibtexParser bp=new BibtexParser(new java.io.StringReader(source.getText()));
    try {
      BibtexDatabase db=bp.parse().getDatabase();
      if (db.getEntryCount() > 1)       throw new Exception("More than one entry found.");
      if (db.getEntryCount() < 1)       throw new Exception("No entries found.");
      NamedCompound compound=new NamedCompound("source edit");
      BibtexEntry nu=db.getEntryById((String)db.getKeySet().iterator().next());
      String id=entry.getId(), newKey=nu.getCiteKey();
      boolean anyChanged=false, duplicateWarning=false;
      if (panel.database.setCiteKeyForEntry(id,newKey))       duplicateWarning=true;
      Object[] fields=entry.getAllFields();
      for (int i=0; i < fields.length; i++)       if (GUIGlobals.isWriteableField(fields[i].toString()))       if (nu.getField(fields[i].toString()) == null) {
        compound.addEdit(new UndoableFieldChange(entry,fields[i].toString(),entry.getField(fields[i].toString()),(Object)null));
        entry.clearField(fields[i].toString());
        anyChanged=true;
      }
      fields=nu.getAllFields();
      for (int i=0; i < fields.length; i++)       if (entry.getField(fields[i].toString()) != nu.getField(fields[i].toString())) {
        String toSet=(String)nu.getField(fields[i].toString());
        (new LatexFieldFormatter()).format(toSet,GUIGlobals.isStandardField(fields[i].toString()));
        compound.addEdit(new UndoableFieldChange(entry,fields[i].toString(),entry.getField(fields[i].toString()),toSet));
        entry.setField(fields[i].toString(),toSet);
        anyChanged=true;
      }
      compound.end();
      if (!anyChanged)       return;
      panel.undoManager.addEdit(compound);
      if (duplicateWarning)       panel.output(Globals.lang("Warning: duplicate bibtex key."));
 else       panel.output(Globals.lang("Stored entry") + ".");
      lastSourceStringAccepted=source.getText();
      updateAllFields();
      lastSourceAccepted=true;
      updateSource=true;
      panel.refreshTable();
      panel.markBaseChanged();
    }
 catch (    Throwable ex) {
      updateSource=false;
      lastSourceAccepted=false;
      tabbed.setSelectedComponent(srcPanel);
      Object[] options={"Edit","Revert to original source"};
      int answer=JOptionPane.showOptionDialog(frame,"Error: " + ex.getMessage(),"Problem with parsing entry",JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE,null,options,options[0]);
      if (answer != 0) {
        updateSource=true;
        updateSource();
      }
    }
  }
}
