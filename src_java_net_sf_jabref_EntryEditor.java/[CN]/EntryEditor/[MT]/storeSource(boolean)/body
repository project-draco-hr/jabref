{
  BibtexParser bp=new BibtexParser(new java.io.StringReader(source.getText()));
  try {
    BibtexDatabase db=bp.parse().getDatabase();
    if (db.getEntryCount() > 1)     throw new Exception("More than one entry found.");
    if (db.getEntryCount() < 1)     throw new Exception("No entries found.");
    NamedCompound compound=new NamedCompound(Globals.lang("source edit"));
    BibtexEntry nu=db.getEntryById(db.getKeySet().iterator().next());
    String id=entry.getId();
    String newKey=nu.getCiteKey();
    boolean anyChanged=false;
    boolean changedType=false;
    boolean duplicateWarning=false;
    boolean emptyWarning=newKey == null || newKey.equals("");
    if (panel.database.setCiteKeyForEntry(id,newKey)) {
      duplicateWarning=true;
    }
    for (    String field : entry.getAllFields()) {
      if (BibtexFields.isDisplayableField(field.toString())) {
        if (nu.getField(field.toString()) == null) {
          compound.addEdit(new UndoableFieldChange(entry,field.toString(),entry.getField(field.toString()),null));
          entry.clearField(field.toString());
          anyChanged=true;
        }
      }
    }
    for (    String field : nu.getAllFields()) {
      if (entry.getField(field.toString()) != nu.getField(field.toString())) {
        String toSet=nu.getField(field.toString());
        (new LatexFieldFormatter()).format(toSet,field.toString());
        compound.addEdit(new UndoableFieldChange(entry,field.toString(),entry.getField(field.toString()),toSet));
        entry.setField(field.toString(),toSet);
        anyChanged=true;
      }
    }
    if (nu.getType() != entry.getType()) {
      compound.addEdit(new UndoableChangeType(entry,entry.getType(),nu.getType()));
      entry.setType(nu.getType());
      anyChanged=true;
      changedType=true;
    }
    compound.end();
    if (!anyChanged)     return true;
    panel.undoManager.addEdit(compound);
    if (duplicateWarning) {
      warnDuplicateBibtexkey();
    }
 else     if (emptyWarning && showError) {
      warnEmptyBibtexkey();
    }
 else {
      panel.output(Globals.lang("Stored entry") + ".");
    }
    lastSourceStringAccepted=source.getText();
    if (!changedType) {
      updateAllFields();
      lastSourceAccepted=true;
      updateSource=true;
    }
 else {
      panel.updateEntryEditorIfShowing();
    }
    panel.markBaseChanged();
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        final int row=panel.mainTable.findEntry(entry);
        if (row >= 0) {
          if (panel.mainTable.getSelectedRowCount() == 0)           panel.mainTable.setRowSelectionInterval(row,row);
          panel.mainTable.ensureVisible(row);
        }
      }
    }
);
    return true;
  }
 catch (  Throwable ex) {
    updateSource=false;
    lastSourceAccepted=false;
    tabbed.setSelectedComponent(srcPanel);
    if (showError) {
      Object[] options={Globals.lang("Edit"),Globals.lang("Revert to original source")};
      int answer=JOptionPane.showOptionDialog(frame,Globals.lang("Error") + ": " + ex.getMessage(),Globals.lang("Problem with parsing entry"),JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE,null,options,options[0]);
      if (answer != 0) {
        updateSource=true;
        updateSource();
      }
    }
    return false;
  }
}
