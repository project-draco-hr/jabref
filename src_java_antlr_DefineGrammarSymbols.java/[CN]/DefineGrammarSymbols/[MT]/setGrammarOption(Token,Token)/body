{
  if (key.getText().equals("tokdef") || key.getText().equals("tokenVocabulary")) {
    tool.error("tokdef/tokenVocabulary options are invalid >= ANTLR 2.6.0.\n" + "  Use importVocab/exportVocab instead.  Please see the documentation.\n" + "  The previous options were so heinous that Terence changed the whole\n"+ "  vocabulary mechanism; it was better to change the names rather than\n"+ "  subtly change the functionality of the known options.  Sorry!",grammar.getFilename(),value.getLine());
  }
 else   if (key.getText().equals("literal") && grammar instanceof LexerGrammar) {
    tool.error("the literal option is invalid >= ANTLR 2.6.0.\n" + "  Use the \"tokens {...}\" mechanism instead.",grammar.getFilename(),value.getLine());
  }
 else   if (key.getText().equals("exportVocab")) {
    if (value.getType() == ANTLRParser.RULE_REF || value.getType() == ANTLRParser.TOKEN_REF) {
      grammar.exportVocab=value.getText();
    }
 else {
      tool.error("exportVocab must be an identifier",grammar.getFilename(),value.getLine());
    }
  }
 else   if (key.getText().equals("importVocab")) {
    if (value.getType() == ANTLRParser.RULE_REF || value.getType() == ANTLRParser.TOKEN_REF) {
      grammar.importVocab=value.getText();
    }
 else {
      tool.error("importVocab must be an identifier",grammar.getFilename(),value.getLine());
    }
  }
 else {
    grammar.setOption(key.getText(),value);
  }
}
