{
  if (key.getText().equals("language")) {
    if (value.getType() == ANTLRParser.STRING_LITERAL) {
      language=StringUtils.stripBack(StringUtils.stripFront(value.getText(),'"'),'"');
    }
 else     if (value.getType() == ANTLRParser.TOKEN_REF || value.getType() == ANTLRParser.RULE_REF) {
      language=value.getText();
    }
 else {
      tool.error("language option must be string or identifier",filename,value.getLine(),value.getColumn());
    }
  }
 else   if (key.getText().equals("mangleLiteralPrefix")) {
    if (value.getType() == ANTLRParser.STRING_LITERAL) {
      tool.literalsPrefix=StringUtils.stripFrontBack(value.getText(),"\"","\"");
    }
 else {
      tool.error("mangleLiteralPrefix option must be string",filename,value.getLine(),value.getColumn());
    }
  }
 else   if (key.getText().equals("upperCaseMangledLiterals")) {
    if (value.getText().equals("true")) {
      tool.upperCaseMangledLiterals=true;
    }
 else     if (value.getText().equals("false")) {
      tool.upperCaseMangledLiterals=false;
    }
 else {
      grammar.antlrTool.error("Value for upperCaseMangledLiterals must be true or false",filename,key.getLine(),key.getColumn());
    }
  }
 else   if (key.getText().equals("namespaceStd") || key.getText().equals("namespaceAntlr") || key.getText().equals("genHashLines")) {
    if (!language.equals("Cpp")) {
      tool.error(key.getText() + " option only valid for C++",filename,key.getLine(),key.getColumn());
    }
 else {
      if (key.getText().equals("noConstructors")) {
        if (!(value.getText().equals("true") || value.getText().equals("false")))         tool.error("noConstructors option must be true or false",filename,value.getLine(),value.getColumn());
        tool.noConstructors=value.getText().equals("true");
      }
 else       if (key.getText().equals("genHashLines")) {
        if (!(value.getText().equals("true") || value.getText().equals("false")))         tool.error("genHashLines option must be true or false",filename,value.getLine(),value.getColumn());
        tool.genHashLines=value.getText().equals("true");
      }
 else {
        if (value.getType() != ANTLRParser.STRING_LITERAL) {
          tool.error(key.getText() + " option must be a string",filename,value.getLine(),value.getColumn());
        }
 else {
          if (key.getText().equals("namespaceStd"))           tool.namespaceStd=value.getText();
 else           if (key.getText().equals("namespaceAntlr"))           tool.namespaceAntlr=value.getText();
        }
      }
    }
  }
 else   if (key.getText().equals("namespace")) {
    if (!language.equals("Cpp") && !language.equals("CSharp")) {
      tool.error(key.getText() + " option only valid for C++ and C# (a.k.a CSharp)",filename,key.getLine(),key.getColumn());
    }
 else {
      if (value.getType() != ANTLRParser.STRING_LITERAL) {
        tool.error(key.getText() + " option must be a string",filename,value.getLine(),value.getColumn());
      }
 else {
        if (key.getText().equals("namespace"))         tool.setNameSpace(value.getText());
      }
    }
  }
 else {
    tool.error("Invalid file-level option: " + key.getText(),filename,key.getLine(),value.getColumn());
  }
}
