{
  final List selected=getSelectedEntries();
  if (selected.size() > 0) {
    NamedCompound ce=new NamedCompound(undoName);
    if (newDatabase) {
      BibtexDatabase base=new BibtexDatabase();
      panel=new BasePanel(frame,base,null,new HashMap(),Globals.prefs);
    }
    boolean groupingCanceled=false;
    for (Iterator i=selected.iterator(); i.hasNext(); ) {
      BibtexEntry entry=(BibtexEntry)i.next();
      Set groups=(Set)groupAdditions.get(entry);
      if (!groupingCanceled && (groups != null)) {
        if (entry.getField(Globals.KEY_FIELD) == null) {
          int answer=JOptionPane.showConfirmDialog(ImportInspectionDialog.this,Globals.lang("Cannot add entries to group without generating keys. Generate keys now?"),Globals.lang("Add to group"),JOptionPane.YES_NO_OPTION);
          if (answer == JOptionPane.YES_OPTION) {
            generateKeys();
          }
 else           groupingCanceled=true;
        }
        if (entry.getField(Globals.KEY_FIELD) != null) {
          for (Iterator i2=groups.iterator(); i2.hasNext(); ) {
            GroupTreeNode node=(GroupTreeNode)i2.next();
            if (node.getGroup().supportsAdd()) {
              AbstractUndoableEdit undo=node.getGroup().add(new BibtexEntry[]{entry});
              if (undo instanceof UndoableChangeAssignment)               ((UndoableChangeAssignment)undo).setEditedNode(node);
              ce.addEdit(undo);
            }
 else {
            }
          }
        }
      }
      try {
        entry.setId(Util.createNeutralId());
        panel.database().insertEntry(entry);
        ce.addEdit(new UndoableInsertEntry(panel.database(),entry,panel));
      }
 catch (      KeyCollisionException e) {
        e.printStackTrace();
      }
    }
    ce.end();
    panel.undoManager.addEdit(ce);
  }
  dispose();
  SwingUtilities.invokeLater(new Thread(){
    public void run(){
      if (newDatabase) {
        frame.addTab(panel,null,true);
      }
      panel.markBaseChanged();
      panel.refreshTable();
      for (Iterator i=callBacks.iterator(); i.hasNext(); ) {
        ((CallBack)i.next()).done(selected.size());
      }
    }
  }
);
}
