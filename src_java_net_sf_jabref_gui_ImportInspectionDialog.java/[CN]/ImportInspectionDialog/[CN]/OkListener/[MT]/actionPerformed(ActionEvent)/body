{
  if (Globals.prefs.getBoolean("warnAboutDuplicatesInInspection")) {
    for (Iterator<BibtexEntry> i=entries.iterator(); i.hasNext(); ) {
      BibtexEntry entry=i.next();
      if (!entry.isSearchHit())       continue;
      if (entry.isGroupHit()) {
        CheckBoxMessage cbm=new CheckBoxMessage(Globals.lang("There are possible duplicates (marked with a 'D' icon) that haven't been resolved. Continue?"),Globals.lang("Disable this confirmation dialog"),false);
        int answer=JOptionPane.showConfirmDialog(ImportInspectionDialog.this,cbm,Globals.lang("Duplicates found"),JOptionPane.YES_NO_OPTION);
        if (cbm.isSelected())         Globals.prefs.putBoolean("warnAboutDuplicatesInInspection",false);
        if (answer == JOptionPane.NO_OPTION)         return;
        break;
      }
    }
  }
  NamedCompound ce=new NamedCompound(undoName);
  if (entriesToDelete.size() > 0) {
    for (Iterator<BibtexEntry> i=entriesToDelete.iterator(); i.hasNext(); ) {
      BibtexEntry entry=i.next();
      ce.addEdit(new UndoableRemoveEntry(panel.database(),entry,panel));
      panel.database().removeEntry(entry.getId());
    }
  }
  if (autoGenerate.isSelected() && !generatedKeys) {
    generateKeys(false);
  }
  Globals.prefs.putBoolean("generateKeysAfterInspection",autoGenerate.isSelected());
  final List<BibtexEntry> selected=getSelectedEntries();
  if (selected.size() > 0) {
    if (newDatabase) {
      BibtexDatabase base=new BibtexDatabase();
      panel=new BasePanel(frame,base,null,new HashMap<String,String>(),Globals.prefs.get("defaultEncoding"));
    }
    boolean groupingCanceled=false;
    Util.setAutomaticFields(selected,Globals.prefs.getBoolean("overwriteOwner"),Globals.prefs.getBoolean("overwriteTimeStamp"),Globals.prefs.getBoolean("markImportedEntries"));
    if (Globals.prefs.getBoolean("unmarkAllEntriesBeforeImporting"))     for (    BibtexEntry entry : panel.database().getEntries()) {
      Util.unmarkEntry(entry,true,panel.database(),ce);
    }
    for (Iterator<BibtexEntry> i=selected.iterator(); i.hasNext(); ) {
      BibtexEntry entry=i.next();
      entry.setSearchHit(false);
      entry.setGroupHit(false);
      Set<GroupTreeNode> groups=groupAdditions.get(entry);
      if (!groupingCanceled && (groups != null)) {
        if (entry.getField(BibtexFields.KEY_FIELD) == null) {
          int answer=JOptionPane.showConfirmDialog(ImportInspectionDialog.this,Globals.lang("Cannot add entries to group without generating keys. Generate keys now?"),Globals.lang("Add to group"),JOptionPane.YES_NO_OPTION);
          if (answer == JOptionPane.YES_OPTION) {
            generateKeys(false);
          }
 else           groupingCanceled=true;
        }
        if (entry.getField(BibtexFields.KEY_FIELD) != null) {
          for (Iterator<GroupTreeNode> i2=groups.iterator(); i2.hasNext(); ) {
            GroupTreeNode node=i2.next();
            if (node.getGroup().supportsAdd()) {
              AbstractUndoableEdit undo=node.getGroup().add(new BibtexEntry[]{entry});
              if (undo instanceof UndoableChangeAssignment)               ((UndoableChangeAssignment)undo).setEditedNode(node);
              ce.addEdit(undo);
            }
 else {
            }
          }
        }
      }
      try {
        entry.setId(Util.createNeutralId());
        panel.database().insertEntry(entry);
        Util.updateCompletersForEntry(panel.getAutoCompleters(),entry);
        ce.addEdit(new UndoableInsertEntry(panel.database(),entry,panel));
      }
 catch (      KeyCollisionException e) {
        e.printStackTrace();
      }
    }
    ce.end();
    panel.undoManager.addEdit(ce);
  }
  dispose();
  SwingUtilities.invokeLater(new Thread(){
    public void run(){
      if (newDatabase) {
        frame.addTab(panel,null,true);
      }
      panel.markBaseChanged();
      if (selected.size() > 0) {
        frame.output(Globals.lang("Number of entries successfully imported") + ": " + selected.size());
      }
 else {
        frame.output(Globals.lang("No entries imported."));
      }
    }
  }
);
}
