{
  int k;
  boolean det=true;
  Vector alts=blk.getAlternatives();
  int nalts=alts.size();
  currentBlock.altj=-1;
  if (DEBUG_ANALYZER)   System.out.println("deterministicImpliedPath");
  for (int i=0; i < nalts; i++) {
    Alternative alt=blk.getAlternativeAt(i);
    if (alt.head instanceof BlockEndElement) {
      tool.warning("empty alternative makes no sense in (...)* or (...)+",grammar.getFilename(),blk.getLine());
    }
    k=1;
    Lookahead[] r=new Lookahead[grammar.maxk + 1];
    boolean haveAmbiguity;
    do {
      haveAmbiguity=false;
      if (DEBUG_ANALYZER)       System.out.println("checking depth " + k + "<="+ grammar.maxk);
      Lookahead p;
      Lookahead follow=blk.next.look(k);
      blk.exitCache[k]=follow;
      currentBlock.alti=i;
      p=getAltLookahead(blk,i,k);
      if (DEBUG_ANALYZER)       System.out.println("follow is " + follow.toString(",",charFormatter,grammar));
      if (DEBUG_ANALYZER)       System.out.println("p is " + p.toString(",",charFormatter,grammar));
      r[k]=follow.intersection(p);
      if (DEBUG_ANALYZER)       System.out.println("intersection at depth " + k + " is "+ r[k]);
      if (!r[k].nil()) {
        haveAmbiguity=true;
        k++;
      }
    }
 while (haveAmbiguity && k <= grammar.maxk);
    if (haveAmbiguity) {
      det=false;
      alt.lookaheadDepth=NONDETERMINISTIC;
      blk.exitLookaheadDepth=NONDETERMINISTIC;
      Alternative ambigAlt=blk.getAlternativeAt(currentBlock.alti);
      if (!blk.warnWhenFollowAmbig) {
      }
 else       if (!blk.generateAmbigWarnings) {
      }
 else       if (blk.greedy == true && blk.greedySet && !(ambigAlt.head instanceof BlockEndElement)) {
        if (DEBUG_ANALYZER)         System.out.println("greedy loop");
      }
 else       if (blk.greedy == false && !(ambigAlt.head instanceof BlockEndElement)) {
        if (DEBUG_ANALYZER)         System.out.println("nongreedy loop");
        if (!lookaheadEquivForApproxAndFullAnalysis(blk.exitCache,grammar.maxk)) {
          tool.warning(new String[]{"nongreedy block may exit incorrectly due","\tto limitations of linear approximate lookahead (first k-1 sets","\tin lookahead not singleton)."},grammar.getFilename(),blk.getLine());
        }
      }
 else {
        tool.errorHandler.warnAltExitAmbiguity(grammar,blk,lexicalAnalysis,grammar.maxk,r,i);
      }
    }
 else {
      alt.lookaheadDepth=Math.max(alt.lookaheadDepth,k);
      blk.exitLookaheadDepth=Math.max(blk.exitLookaheadDepth,k);
    }
  }
  return det;
}
