{
  this.tree=tree;
  this.buildInFunctions=new HashMap<String,BstFunction>(37);
  buildInFunctions.put(">",new BstFunction(){
    /** 
 * Pops the top two (integer) literals, compares them, and pushes
 * the integer 1 if the second is greater than the first, 0
 * otherwise.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation >");
      }
      Object o2=stack.pop();
      Object o1=stack.pop();
      if (!(o1 instanceof Integer && o2 instanceof Integer)) {
        throw new VMException("Can only compare two integers with >");
      }
      if (o1 == o2) {
        stack.push(VM.FALSE);
        return;
      }
      stack.push(((Integer)o1).compareTo((Integer)o2) > 0 ? VM.TRUE : VM.FALSE);
    }
  }
);
  buildInFunctions.put("<",new BstFunction(){
    /** 
 * Analogous. 
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation <");
      }
      Object o2=stack.pop();
      Object o1=stack.pop();
      if (!(o1 instanceof Integer && o2 instanceof Integer)) {
        throw new VMException("Can only compare two integers with <");
      }
      if (o1 == o2) {
        stack.push(VM.FALSE);
        return;
      }
      stack.push(((Integer)o1).compareTo((Integer)o2) < 0 ? VM.TRUE : VM.FALSE);
    }
  }
);
  buildInFunctions.put("=",new BstFunction(){
    /** 
 * Pops the top two (both integer or both string) literals, compares
 * them, and pushes the integer 1 if they're equal, 0 otherwise.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation =");
      }
      Object o1=stack.pop();
      Object o2=stack.pop();
      if (o1 == null ^ o2 == null) {
        stack.push(VM.FALSE);
        return;
      }
      if (o1 == o2) {
        stack.push(VM.TRUE);
        return;
      }
      stack.push(o1.equals(o2) ? VM.TRUE : VM.FALSE);
    }
  }
);
  buildInFunctions.put("+",new BstFunction(){
    /** 
 * Pops the top two (integer) literals and pushes their sum. 
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation +");
      }
      Object o2=stack.pop();
      Object o1=stack.pop();
      if (!(o1 instanceof Integer && o2 instanceof Integer)) {
        throw new VMException("Can only compare two integers with +");
      }
      stack.push(((Integer)o1).intValue() + ((Integer)o2).intValue());
    }
  }
);
  buildInFunctions.put("-",new BstFunction(){
    /** 
 * Pops the top two (integer) literals and pushes their difference
 * (the first subtracted from the second).
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation -");
      }
      Object o2=stack.pop();
      Object o1=stack.pop();
      if (!(o1 instanceof Integer && o2 instanceof Integer)) {
        throw new VMException("Can only subtract two integers with -");
      }
      stack.push(((Integer)o1).intValue() - ((Integer)o2).intValue());
    }
  }
);
  buildInFunctions.put("*",new BstFunction(){
    /** 
 * Pops the top two (string) literals, concatenates them (in reverse
 * order, that is, the order in which pushed), and pushes the
 * resulting string.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation *");
      }
      Object o2=stack.pop();
      Object o1=stack.pop();
      if (!(o1 instanceof String && o2 instanceof String)) {
        throw new VMException("Can only concatenate two String with *");
      }
      stack.push(o1.toString() + o2.toString());
    }
  }
);
  buildInFunctions.put(":=",new BstFunction(){
    /** 
 * Pops the top two literals and assigns to the first (which must be
 * a global or entry variable) the value of the second.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Invalid call to operation :=");
      }
      Object o1=stack.pop();
      Object o2=stack.pop();
      assign(context,o1,o2);
    }
  }
);
  buildInFunctions.put("add.period$",new BstFunction(){
    Pattern p=Pattern.compile("([^\\.\\?\\!\\}\\s])(\\}|\\s)*$");
    /** 
 * Pops the top (string) literal, adds a `.' to it if the last non
 * '}' character isn't a `.', `?', or `!', and pushes this resulting
 * string.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation add.period$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof String)) {
        throw new VMException("Can only add a period to a string for add.period$");
      }
      String s=(String)o1;
      Matcher m=p.matcher(s);
      if (m.find()) {
        StringBuffer sb=new StringBuffer();
        m.appendReplacement(sb,m.group(1));
        sb.append('.');
        String group2=m.group(2);
        if (group2 != null)         sb.append(m.group(2));
        stack.push(sb.toString());
      }
 else {
        stack.push(s);
      }
    }
  }
);
  buildInFunctions.put("call.type$",new BstFunction(){
    /** 
 * Executes the function whose name is the entry type of an entry.
 * For example if an entry is of type book, this function executes
 * the book function. When given as an argument to the ITERATE
 * command, call.type$ actually produces the output for the entries.
 * For an entry with an unknown type, it executes the function
 * default.type. Thus you should define (before the READ command)
 * one function for each standard entry type as well as a
 * default.type function.
 */
    public void execute(    BstEntry context){
      if (context == null) {
        throw new VMException("Call.type$ can only be called from within a context (ITERATE or REVERSE).");
      }
      VM.this.execute(context.entry.getType().getName().toLowerCase(),context);
    }
  }
);
  buildInFunctions.put("change.case$",new ChangeCaseFunction(this));
  buildInFunctions.put("chr.to.int$",new BstFunction(){
    /** 
 * Pops the top (string) literal, makes sure it's a single
 * character, converts it to the corresponding ASCII integer, and
 * pushes this integer.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation chr.to.int$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof String && ((String)o1).length() == 1)) {
        throw new VMException("Can only perform chr.to.int$ on string with length 1");
      }
      String s=(String)o1;
      stack.push((int)s.charAt(0));
    }
  }
);
  buildInFunctions.put("cite$",new BstFunction(){
    /** 
 * Pushes the string that was the \cite-command argument for this
 * entry.
 */
    public void execute(    BstEntry context){
      stack.push(context.entry.getCiteKey());
    }
  }
);
  buildInFunctions.put("duplicate$",new BstFunction(){
    /** 
 * Pops the top literal from the stack and pushes two copies of it.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation duplicate$");
      }
      Object o1=stack.pop();
      stack.push(o1);
      stack.push(o1);
    }
  }
);
  buildInFunctions.put("empty$",new BstFunction(){
    /** 
 * Pops the top literal and pushes the integer 1 if it's a missing
 * field or a string having no non-white-space characters, 0
 * otherwise.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation empty$");
      }
      Object o1=stack.pop();
      if (o1 == null) {
        stack.push(VM.TRUE);
        return;
      }
      if (!(o1 instanceof String)) {
        throw new VMException("Operand does not match function empty$");
      }
      String s=(String)o1;
      stack.push(s.trim().equals("") ? VM.TRUE : VM.FALSE);
    }
  }
);
  buildInFunctions.put("format.name$",new FormatNameFunction(this));
  buildInFunctions.put("if$",new BstFunction(){
    /** 
 * Pops the top three literals (they are two function literals and
 * an integer literal, in that order); if the integer is greater
 * than 0, it executes the second literal, else it executes the
 * first.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 3) {
        throw new VMException("Not enough operands on stack for operation =");
      }
      Object f1=stack.pop();
      Object f2=stack.pop();
      Object i=stack.pop();
      if (!(f1 instanceof Identifier || f1 instanceof Tree) && (f2 instanceof Identifier || f2 instanceof Tree) && (i instanceof Integer)) {
        throw new VMException("Expecting two functions and an integer for if$.");
      }
      Object toExe;
      if ((Integer)i > 0) {
        toExe=f2;
      }
 else {
        toExe=f1;
      }
      VM.this.executeInContext(toExe,context);
    }
  }
);
  buildInFunctions.put("int.to.chr$",new BstFunction(){
    /** 
 * Pops the top (integer) literal, interpreted as the ASCII integer
 * value of a single character, converts it to the corresponding
 * single-character string, and pushes this string.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation int.to.chr$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof Integer)) {
        throw new VMException("Can only perform operation int.to.chr$ on an Integer");
      }
      Integer i=(Integer)o1;
      stack.push(String.valueOf((char)i.intValue()));
    }
  }
);
  buildInFunctions.put("int.to.str$",new BstFunction(){
    /** 
 * Pops the top (integer) literal, converts it to its (unique)
 * string equivalent, and pushes this string.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation int.to.str$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof Integer)) {
        throw new VMException("Can only transform an integer to an string using int.to.str$");
      }
      stack.push(o1.toString());
    }
  }
);
  buildInFunctions.put("missing$",new BstFunction(){
    /** 
 * Pops the top literal and pushes the integer 1 if it's a missing
 * field, 0 otherwise.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation missing$");
      }
      Object o1=stack.pop();
      if (o1 == null) {
        stack.push(VM.TRUE);
        return;
      }
      if (!(o1 instanceof String)) {
        warn("Not a string or missing field in operation missing$");
        stack.push(VM.TRUE);
        return;
      }
      stack.push(VM.FALSE);
    }
  }
);
  buildInFunctions.put("newline$",new BstFunction(){
    /** 
 * Writes onto the bbl file what's accumulated in the output buffer.
 * It writes a blank line if and only if the output buffer is empty.
 * Since write$ does reasonable line breaking, you should use this
 * function only when you want a blank line or an explicit line
 * break.
 */
    public void execute(    BstEntry context){
      VM.this.bbl.append('\n');
    }
  }
);
  buildInFunctions.put("num.names$",new BstFunction(){
    /** 
 * Pops the top (string) literal and pushes the number of names the
 * string represents one plus the number of occurrences of the
 * substring "and" (ignoring case differences) surrounded by
 * non-null white-space at the top brace level.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation num.names$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof String)) {
        throw new VMException("Need a string at the top of the stack for num.names$");
      }
      String s=(String)o1;
      stack.push(AuthorList.getAuthorList(s).size());
    }
  }
);
  buildInFunctions.put("pop$",new BstFunction(){
    /** 
 * Pops the top of the stack but doesn't print it; this gets rid of
 * an unwanted stack literal.
 */
    public void execute(    BstEntry context){
      stack.pop();
    }
  }
);
  buildInFunctions.put("preamble$",new BstFunction(){
    /** 
 * The |built_in| function {\.{preamble\$}} pushes onto the stack
 * the concatenation of all the \.{preamble} strings read from the
 * database files. (or the empty string if there where none)
 * @PREAMBLE strings read from the database files.
 */
    public void execute(    BstEntry context){
      if (preamble != null) {
        stack.push(preamble);
      }
 else {
        stack.push("");
      }
    }
  }
);
  buildInFunctions.put("purify$",new PurifyFunction(this));
  buildInFunctions.put("quote$",new BstFunction(){
    /** 
 * Pushes the string consisting of the double-quote character.
 */
    public void execute(    BstEntry context){
      stack.push("\"");
    }
  }
);
  buildInFunctions.put("skip$",new BstFunction(){
    /** 
 * Is a no-op.
 */
    public void execute(    BstEntry context){
    }
  }
);
  buildInFunctions.put("stack$",new BstFunction(){
    /** 
 * Pops and prints the whole stack; it's meant to be used for style
 * designers while debugging.
 */
    public void execute(    BstEntry context){
      while (!stack.empty()) {
        System.out.println(stack.pop());
      }
    }
  }
);
  buildInFunctions.put("substring$",new BstFunction(){
    /** 
 * Pops the top three literals (they are the two integers literals
 * len and start, and a string literal, in that order). It pushes
 * the substring of the (at most) len consecutive characters
 * starting at the startth character (assuming 1-based indexing) if
 * start is positive, and ending at the start-th character
 * (including) from the end if start is negative (where the first
 * character from the end is the last character).
 */
    public void execute(    BstEntry context){
      if (stack.size() < 3) {
        throw new VMException("Not enough operands on stack for operation substring$");
      }
      Object o1=stack.pop();
      Object o2=stack.pop();
      Object o3=stack.pop();
      if (!((o1 instanceof Integer) && (o2 instanceof Integer) && (o3 instanceof String))) {
        throw new VMException("Expecting two integers and a string for substring$");
      }
      Integer len=(Integer)o1;
      Integer start=(Integer)o2;
      int lenI=len;
      int startI=start;
      if (lenI > Integer.MAX_VALUE / 2)       lenI=Integer.MAX_VALUE / 2;
      if (startI > Integer.MAX_VALUE / 2)       startI=Integer.MAX_VALUE / 2;
      if (startI < Integer.MIN_VALUE / 2)       startI=-Integer.MIN_VALUE / 2;
      String s=(String)o3;
      if (startI < 0) {
        startI+=s.length() + 1;
        startI=Math.max(1,startI + 1 - lenI);
      }
      stack.push(s.substring(startI - 1,Math.min(startI - 1 + lenI,s.length())));
    }
  }
);
  buildInFunctions.put("swap$",new BstFunction(){
    /** 
 * Swaps the top two literals on the stack. text.length$ Pops the
 * top (string) literal, and pushes the number of text char- acters
 * it contains, where an accented character (more precisely, a
 * \special character", defined in Section 4) counts as a single
 * text character, even if it's missing its matching right brace,
 * and where braces don't count as text characters.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation swap$");
      }
      Object f1=stack.pop();
      Object f2=stack.pop();
      stack.push(f1);
      stack.push(f2);
    }
  }
);
  buildInFunctions.put("text.length$",new BstFunction(){
    /** 
 * text.length$ Pops the top (string) literal, and pushes the number
 * of text characters it contains, where an accented character (more
 * precisely, a "special character", defined in Section 4) counts as
 * a single text character, even if it's missing its matching right
 * brace, and where braces don't count as text characters.
 * From BibTeXing: For the purposes of counting letters in labels,
 * BibTEX considers everything contained inside the braces as a
 * single letter.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 1) {
        throw new VMException("Not enough operands on stack for operation text.length$");
      }
      Object o1=stack.pop();
      if (!(o1 instanceof String)) {
        throw new VMException("Can only perform operation on a string text.length$");
      }
      String s=(String)o1;
      char[] c=s.toCharArray();
      int result=0;
      int i=0;
      int n=s.length();
      int braceLevel=0;
      while (i < n) {
        i++;
        if (c[i - 1] == '{') {
          braceLevel++;
          if (braceLevel == 1 && i < n)           if (c[i] == '\\') {
            i++;
            while (i < n && braceLevel > 0) {
              if (c[i] == '}')               braceLevel--;
 else               if (c[i] == '{')               braceLevel++;
              i++;
            }
            result++;
          }
        }
 else         if (c[i - 1] == '}') {
          if (braceLevel > 0)           braceLevel--;
        }
 else         result++;
      }
      stack.push(result);
    }
  }
);
  buildInFunctions.put("text.prefix$",new TextPrefixFunction(this));
  buildInFunctions.put("top$",new BstFunction(){
    /** 
 * Pops and prints the top of the stack on the terminal and log
 * file. It's useful for debugging.
 */
    public void execute(    BstEntry context){
      System.out.println(stack.pop());
    }
  }
);
  buildInFunctions.put("type$",new BstFunction(){
    /** 
 * Pushes the current entry's type (book, article, etc.), but pushes
 * the null string if the type is either unknown or undefined.
 */
    public void execute(    BstEntry context){
      stack.push(context.entry.getType().getName());
    }
  }
);
  buildInFunctions.put("warning$",new BstFunction(){
    /** 
 * Pops the top (string) literal and prints it following a warning
 * message. This also increments a count of the number of warning
 * messages issued.
 */
    int warning=1;
    public void execute(    BstEntry context){
      out.println("Warning (#" + (warning++) + "): "+ stack.pop());
    }
  }
);
  buildInFunctions.put("while$",new BstFunction(){
    /** 
 * Pops the top two (function) literals, and keeps executing the
 * second as long as the (integer) literal left on the stack by
 * executing the first is greater than 0.
 */
    public void execute(    BstEntry context){
      if (stack.size() < 2) {
        throw new VMException("Not enough operands on stack for operation while$");
      }
      Object f2=stack.pop();
      Object f1=stack.pop();
      if (!(f1 instanceof Identifier || f1 instanceof Tree) && (f2 instanceof Identifier || f2 instanceof Tree)) {
        throw new VMException("Expecting two functions for while$.");
      }
      do {
        VM.this.executeInContext(f1,context);
        Object i=stack.pop();
        if (!(i instanceof Integer)) {
          throw new VMException("First parameter to while has to return an integer but was " + i);
        }
        if ((Integer)i <= 0) {
          break;
        }
        VM.this.executeInContext(f2,context);
      }
 while (true);
    }
  }
);
  buildInFunctions.put("width$",new WidthFunction(this));
  buildInFunctions.put("write$",new BstFunction(){
    /** 
 * Pops the top (string) literal and writes it on the output buffer
 * (which will result in stuff being written onto the bbl file when
 * the buffer fills up).
 */
    public void execute(    BstEntry context){
      String s=(String)stack.pop();
      System.out.println(s);
      VM.this.bbl.append(s);
    }
  }
);
}
