{
  GroupTreeNode cursor=m_groupsRootHandle;
  final int childIndex=m_pathToNode[m_pathToNode.length - 1];
  for (int i=0; i < (m_pathToNode.length - 1); ++i) {
    cursor=(GroupTreeNode)cursor.getChildAt(m_pathToNode[i]);
  }
  if (undo) {
switch (m_editType) {
case ADD_NODE:
      cursor.remove(childIndex);
    break;
case REMOVE_NODE_KEEP_CHILDREN:
  GroupTreeNode newNode=m_subtreeBackup.deepCopy();
for (int i=childIndex; i < (childIndex + m_subtreeRootChildCount); ++i) {
  newNode.add((GroupTreeNode)cursor.getChildAt(childIndex));
}
cursor.insert(newNode,childIndex);
break;
case REMOVE_NODE_AND_CHILDREN:
cursor.insert(m_subtreeBackup.deepCopy(),childIndex);
break;
default :
break;
}
}
 else {
switch (m_editType) {
case ADD_NODE:
cursor.insert(m_subtreeBackup.deepCopy(),childIndex);
break;
case REMOVE_NODE_KEEP_CHILDREN:
GroupTreeNode removedNode=(GroupTreeNode)cursor.getChildAt(childIndex);
cursor.remove(childIndex);
while (removedNode.getChildCount() > 0) {
cursor.insert((GroupTreeNode)removedNode.getFirstChild(),childIndex);
}
break;
case REMOVE_NODE_AND_CHILDREN:
cursor.remove(childIndex);
break;
default :
break;
}
}
if (mRevalidate) {
m_groupSelector.revalidateGroups();
}
}
