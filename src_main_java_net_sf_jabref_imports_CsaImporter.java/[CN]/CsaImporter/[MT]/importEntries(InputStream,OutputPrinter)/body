{
  ArrayList<BibtexEntry> bibitems=new ArrayList<>();
  StringBuilder sb=new StringBuilder();
  HashMap<String,String> hm=new HashMap<>();
  BufferedReader in=new BufferedReader(ImportFormatReader.getReaderDefaultEncoding(stream));
  String Type=null;
  String str;
  boolean first=true;
  line=1;
  str=readLine(in);
  while (true) {
    if (str == null || str.isEmpty()) {
      if (!hm.isEmpty()) {
        if (Type == null) {
          addNote(hm,"Publication Type: [NOT SPECIFIED]");
          addNote(hm,"[PERHAPS NOT FULL FORMAT]");
          Type="article";
        }
        if (Type.equals("article") && hm.get("booktitle") != null) {
          String booktitle=hm.get("booktitle");
          hm.remove("booktitle");
          hm.put("journal",booktitle);
        }
        BibtexEntry b=new BibtexEntry(BibtexFields.DEFAULT_BIBTEXENTRY_ID,Globals.getEntryType(Type));
        b.setField(hm);
        bibitems.add(b);
      }
      hm.clear();
      first=true;
      if (str == null) {
        break;
      }
      str=readLine(in);
      continue;
    }
    int fline=line;
    Matcher fm=CsaImporter.FIELD_PATTERN.matcher(str);
    if (fm.find()) {
      String fabbr=fm.group(1);
      String fname=fm.group(2);
      sb.setLength(0);
      while ((str=readLine(in)) != null) {
        if (!str.startsWith("    ")) {
          break;
        }
        if (sb.length() > 0) {
          sb.append(" ");
        }
        sb.append(str.substring(4));
      }
      String fstr=sb.toString();
      if (fstr.isEmpty()) {
        int line1=line - 1;
        throw new IOException("illegal empty field at line " + line1);
      }
      fm=CsaImporter.LT_PATTERN.matcher(fstr);
      if (fm.find()) {
        fstr=fm.replaceAll("<");
      }
      if (fabbr.equals("DN") && fname.equalsIgnoreCase("Database Name")) {
        if (!first) {
          throw new IOException("format error at line " + fline + ": DN out of order");
        }
        first=false;
      }
 else       if (first) {
        throw new IOException("format error at line " + fline + ": missing DN");
      }
      if (fabbr.equals("PT")) {
        Type=null;
        String flow=fstr.toLowerCase();
        String[] types=flow.split("; ");
        for (        String type : types) {
          if (type.contains("article") || type.contains("journal article")) {
            Type="article";
            break;
          }
 else           if (type.equals("dissertation")) {
            Type="phdthesis";
            break;
          }
 else           if (type.equals("conference")) {
            Type="inproceedings";
            break;
          }
 else           if (type.equals("book monograph") && Type == null) {
            Type="book";
            break;
          }
 else           if (type.equals("report") && Type == null) {
            Type="techreport";
            break;
          }
        }
        if (Type == null) {
          Type="misc";
        }
      }
      String ftype=null;
switch (fabbr) {
case "AB":
        ftype="abstract";
      break;
case "AF":
    ftype="affiliation";
  break;
case "AU":
ftype="author";
if (fstr.contains(";")) {
fstr=fstr.replaceAll("; "," and ");
}
break;
case "CA":
ftype="organization";
break;
case "DE":
ftype="keywords";
break;
case "DO":
ftype="doi";
break;
case "ED":
ftype="editor";
break;
case "IB":
ftype="ISBN";
break;
case "IS":
ftype="ISSN";
break;
case "JN":
ftype="journal";
break;
case "LA":
ftype="language";
break;
case "PB":
ftype="publisher";
break;
case "PY":
ftype="year";
if (hm.get("year") != null) {
String oyear=hm.get("year");
if (!fstr.equals(oyear)) {
addNote(hm,"Source Year: " + oyear + ".");
}
}
break;
case "RL":
ftype="url";
String[] lines=fstr.split(" ");
StringBuilder urls=new StringBuilder();
for (int ii=0; ii < lines.length; ++ii) {
if (lines[ii].startsWith("[URL:")) {
urls.append(lines[ii].substring(5));
}
 else if (lines[ii].endsWith("]")) {
int len=lines[ii].length();
urls.append(lines[ii].substring(0,len - 1));
if (ii < lines.length - 1) {
urls.append("\n");
}
}
 else {
urls.append(lines[ii]);
}
}
fstr=urls.toString();
break;
case "SO":
ftype="booktitle";
Matcher pm=CsaImporter.VOLNOPP_PATTERN.matcher(fstr);
if (pm.find()) {
hm.put("volume",pm.group(1));
hm.put("number",pm.group(2));
hm.put("pages",pm.group(3));
fstr=pm.replaceFirst("");
}
pm=CsaImporter.PAGES_PATTERN.matcher(fstr);
StringBuilder pages=new StringBuilder();
while (pm.find()) {
if (pages.length() > 0) {
pages.append(",");
}
String pp=pm.group(1);
if (pp == null) {
pp=pm.group(2);
}
if (pp == null) {
pp=pm.group(3);
}
pages.append(pp);
fstr=pm.replaceFirst("");
pm=CsaImporter.PAGES_PATTERN.matcher(fstr);
}
if (pages.length() > 0) {
hm.put("pages",pages.toString());
}
pm=CsaImporter.VOLUME_PATTERN.matcher(fstr);
if (pm.find()) {
hm.put("volume",pm.group(1));
fstr=pm.replaceFirst("");
}
pm=CsaImporter.NUMBER_PATTERN.matcher(fstr);
if (pm.find()) {
hm.put("number",pm.group(1));
fstr=pm.replaceFirst("");
}
fstr=parseDate(hm,fstr);
Pattern pp=Pattern.compile(",?\\s*$");
pm=pp.matcher(fstr);
if (pm.find()) {
fstr=pm.replaceFirst("");
}
if (fstr.equals("")) {
continue;
}
break;
case "TI":
ftype="title";
break;
case "RE":
continue;
}
if (ftype != null) {
hm.put(ftype,fstr);
}
 else {
addNote(hm,fname + ": " + fstr+ ".");
}
}
 else {
str=readLine(in);
}
}
return bibitems;
}
