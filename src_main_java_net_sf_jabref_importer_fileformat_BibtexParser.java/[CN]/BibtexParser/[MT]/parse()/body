{
  if (parserResult != null) {
    return parserResult;
  }
  database=new BibtexDatabase();
  HashMap<String,String> meta=new HashMap<>();
  entryTypes=new HashMap<>();
  parserResult=new ParserResult(database,null,entryTypes);
  String versionNum=readJabRefVersionNumber();
  if (versionNum != null) {
    parserResult.setJabrefVersion(versionNum);
    setMajorMinorVersions();
  }
  skipWhitespace();
  try {
    while (!eof) {
      boolean found=consumeUncritically('@');
      if (!found) {
        break;
      }
      skipWhitespace();
      String entryType=parseTextToken();
      EntryType tp=EntryTypes.getType(entryType);
      boolean isEntry=tp != null;
      if (!isEntry) {
        if (entryType.toLowerCase().equals("preamble")) {
          database.setPreamble(parsePreamble());
        }
 else         if (entryType.toLowerCase().equals("string")) {
          BibtexString bs=parseString();
          try {
            database.addString(bs);
          }
 catch (          KeyCollisionException ex) {
            parserResult.addWarning(Localization.lang("Duplicate string name") + ": " + bs.getName());
          }
        }
 else         if (entryType.toLowerCase().equals("comment")) {
          StringBuffer commentBuf=parseBracketedTextExactly();
          String comment=commentBuf.toString().replaceAll("[\\x0d\\x0a]","");
          if (comment.substring(0,Math.min(comment.length(),GUIGlobals.META_FLAG.length())).equals(GUIGlobals.META_FLAG) || comment.substring(0,Math.min(comment.length(),GUIGlobals.META_FLAG_OLD.length())).equals(GUIGlobals.META_FLAG_OLD)) {
            String rest;
            if (comment.substring(0,GUIGlobals.META_FLAG.length()).equals(GUIGlobals.META_FLAG)) {
              rest=comment.substring(GUIGlobals.META_FLAG.length());
            }
 else {
              rest=comment.substring(GUIGlobals.META_FLAG_OLD.length());
            }
            int pos=rest.indexOf(':');
            if (pos > 0) {
              meta.put(rest.substring(0,pos),rest.substring(pos + 1));
            }
          }
 else           if (comment.substring(0,Math.min(comment.length(),CustomEntryType.ENTRYTYPE_FLAG.length())).equals(CustomEntryType.ENTRYTYPE_FLAG)) {
            CustomEntryType typ=CustomEntryTypesManager.parseEntryType(comment);
            entryTypes.put(typ.getName(),typ);
          }
 else {
            LOGGER.info("Dropped comment from database: " + comment);
          }
        }
 else {
          tp=new UnknownEntryType(EntryUtil.capitalizeFirst(entryType));
          isEntry=true;
        }
      }
      if (isEntry) {
        try {
          BibtexEntry be=parseEntry(tp);
          boolean duplicateKey=database.insertEntry(be);
          if (duplicateKey) {
            parserResult.addDuplicateKey(be.getCiteKey());
          }
 else           if ((be.getCiteKey() == null) || be.getCiteKey().equals("")) {
            parserResult.addWarning(Localization.lang("Empty BibTeX key") + ": " + be.getAuthorTitleYear(40)+ " ("+ Localization.lang("Grouping may not work for this entry.")+ ")");
          }
        }
 catch (        IOException ex) {
          LOGGER.warn("Could not parse entry",ex);
          parserResult.addWarning(Localization.lang("Error occurred when parsing entry") + ": '" + ex.getMessage()+ "'. "+ Localization.lang("Skipped entry."));
        }
      }
      skipWhitespace();
    }
    checkEntryTypes(parserResult);
    parserResult.setMetaData(new MetaData(meta,database));
    return parserResult;
  }
 catch (  KeyCollisionException kce) {
    throw new IOException("Duplicate ID in bibtex file: " + kce);
  }
}
