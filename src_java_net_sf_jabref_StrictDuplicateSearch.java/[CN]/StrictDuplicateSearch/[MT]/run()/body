{
  HashSet toRemove=new HashSet();
  NamedCompound ce=new NamedCompound(Globals.lang("Remove duplicates"));
  int duplicateCounter=0;
  panel.output(Globals.lang("Searching for duplicates..."));
  Object[] keys=panel.database.getKeySet().toArray();
  if ((keys == null) || (keys.length < 2))   return;
  BibtexEntry[] bes=new BibtexEntry[keys.length];
  for (int i=0; i < keys.length; i++)   bes[i]=panel.database.getEntryById((String)keys[i]);
  for (int i=0; i < bes.length - 1; i++) {
    for (int j=i + 1; j < bes.length; j++) {
      if (!toRemove.contains(bes[i]) && !toRemove.contains(bes[j]) && Util.compareEntriesStrictly(bes[i],bes[j]) > 1) {
        if (!toRemove.contains(bes[i]) && !toRemove.contains(bes[j])) {
          toRemove.add(bes[j]);
        }
      }
    }
  }
  panel.output(Globals.lang("Duplicates removed") + ": " + toRemove.size());
  if (toRemove.size() == 0) {
    return;
  }
  for (Iterator i=toRemove.iterator(); i.hasNext(); ) {
    BibtexEntry entry=(BibtexEntry)i.next();
    panel.database.removeEntry(entry.getId());
    ce.addEdit(new UndoableRemoveEntry(panel.database,entry,panel));
  }
  ce.end();
  panel.undoManager.addEdit(ce);
  dispose();
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      panel.markBaseChanged();
      panel.refreshTable();
    }
  }
);
}
