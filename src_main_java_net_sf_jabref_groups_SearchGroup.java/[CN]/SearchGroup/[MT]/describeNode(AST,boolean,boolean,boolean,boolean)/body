{
  StringBuffer sb=new StringBuffer();
switch (node.getType()) {
case SearchExpressionTreeParserTokenTypes.And:
    if (not) {
      sb.append(Globals.lang("not")).append(' ');
    }
  if (or || not) {
    sb.append('(');
  }
sb.append(SearchGroup.describeNode(node.getFirstChild(),regExp,false,true,false)).append(' ').append(Globals.lang("and")).append(' ').append(SearchGroup.describeNode(node.getFirstChild().getNextSibling(),regExp,false,true,false));
if (or || not) {
sb.append(')');
}
return sb.toString();
case SearchExpressionTreeParserTokenTypes.Or:
if (not) {
sb.append(Globals.lang("not")).append(' ');
}
if (and || not) {
sb.append('(');
}
sb.append(SearchGroup.describeNode(node.getFirstChild(),regExp,false,false,true)).append(' ').append(Globals.lang("or")).append(' ').append(SearchGroup.describeNode(node.getFirstChild().getNextSibling(),regExp,false,false,true));
if (and || not) {
sb.append(')');
}
return sb.toString();
case SearchExpressionTreeParserTokenTypes.Not:
return SearchGroup.describeNode(node.getFirstChild(),regExp,!not,and,or);
default :
node=node.getFirstChild();
final String field=node.getText();
final boolean regExpFieldSpec=!Pattern.matches("\\w+",field);
node=node.getNextSibling();
final int type=node.getType();
node=node.getNextSibling();
final String termQuoted=Util.quoteForHTML(node.getText());
final String fieldSpecQuoted=regExpFieldSpec ? Globals.lang("any field that matches the regular expression <b>%0</b>",Util.quoteForHTML(field)) : Globals.lang("the field <b>%0</b>",Util.quoteForHTML(field));
switch (type) {
case SearchExpressionTreeParserTokenTypes.LITERAL_contains:
case SearchExpressionTreeParserTokenTypes.EQUAL:
if (regExp) {
return not ? Globals.lang("%0 doesn't contain the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 contains the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted);
}
return not ? Globals.lang("%0 doesn't contain the term <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 contains the term <b>%1</b>",fieldSpecQuoted,termQuoted);
case SearchExpressionTreeParserTokenTypes.LITERAL_matches:
case SearchExpressionTreeParserTokenTypes.EEQUAL:
if (regExp) {
return not ? Globals.lang("%0 doesn't match the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 matches the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted);
}
return not ? Globals.lang("%0 doesn't match the term <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 matches the term <b>%1</b>",fieldSpecQuoted,termQuoted);
case SearchExpressionTreeParserTokenTypes.NEQUAL:
if (regExp) {
return not ? Globals.lang("%0 contains the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 doesn't contain the Regular Expression <b>%1</b>",fieldSpecQuoted,termQuoted);
}
return not ? Globals.lang("%0 contains the term <b>%1</b>",fieldSpecQuoted,termQuoted) : Globals.lang("%0 doesn't contain the term <b>%1</b>",fieldSpecQuoted,termQuoted);
default :
return "Internal error: Unknown AST node type. " + "Please report this on www.sf.net/projects/jabref";
}
}
}
