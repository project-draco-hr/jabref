{
  BibtexDatabase fromDatabase=pr.getDatabase();
  ArrayList<BibtexEntry> appendedEntries=new ArrayList<BibtexEntry>();
  ArrayList<BibtexEntry> originalEntries=new ArrayList<BibtexEntry>();
  BibtexDatabase database=panel.database();
  BibtexEntry originalEntry;
  NamedCompound ce=new NamedCompound(Globals.lang("Append database"));
  MetaData meta=pr.getMetaData();
  if (importEntries) {
    boolean overwriteOwner=Globals.prefs.getBoolean("overwriteOwner");
    boolean overwriteTimeStamp=Globals.prefs.getBoolean("overwriteTimeStamp");
    for (    String key : fromDatabase.getKeySet()) {
      originalEntry=fromDatabase.getEntryById(key);
      BibtexEntry be=(BibtexEntry)(originalEntry.clone());
      be.setId(Util.createNeutralId());
      Util.setAutomaticFields(be,overwriteOwner,overwriteTimeStamp);
      database.insertEntry(be);
      appendedEntries.add(be);
      originalEntries.add(originalEntry);
      ce.addEdit(new UndoableInsertEntry(database,be,panel));
    }
  }
  if (importStrings) {
    for (    BibtexString bs : fromDatabase.getStringValues()) {
      if (!database.hasStringLabel(bs.getName())) {
        database.addString(bs);
        ce.addEdit(new UndoableInsertString(panel,database,bs));
      }
    }
  }
  if (importGroups) {
    GroupTreeNode newGroups=meta.getGroups();
    if (newGroups != null) {
      if (newGroups.getGroup() instanceof AllEntriesGroup) {
        ExplicitGroup group=new ExplicitGroup("Imported",AbstractGroup.INDEPENDENT);
        newGroups.setGroup(group);
        for (int i=0; i < appendedEntries.size(); ++i)         group.addEntry(appendedEntries.get(i));
      }
      frame.groupSelector.addGroups(newGroups,ce);
      GroupTreeNode node;
      ExplicitGroup group;
      BibtexEntry entry;
      for (Enumeration<GroupTreeNode> e=newGroups.preorderEnumeration(); e.hasMoreElements(); ) {
        node=e.nextElement();
        if (!(node.getGroup() instanceof ExplicitGroup))         continue;
        group=(ExplicitGroup)node.getGroup();
        for (int i=0; i < originalEntries.size(); ++i) {
          entry=originalEntries.get(i);
          if (group.contains(entry)) {
            group.removeEntry(entry);
            group.addEntry(appendedEntries.get(i));
          }
        }
      }
      frame.groupSelector.revalidateGroups();
    }
  }
  if (importSelectorWords) {
    for (    String s : meta) {
      if (s.startsWith(Globals.SELECTOR_META_PREFIX)) {
        panel.metaData().putData(s,meta.getData(s));
      }
    }
  }
  ce.end();
  panel.undoManager.addEdit(ce);
  panel.markBaseChanged();
}
