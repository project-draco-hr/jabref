{
  List<BibtexEntry> toGenerateFor=new ArrayList<>();
  for (  String key : dupes.keySet()) {
    ResolveDuplicateLabelDialog rdld=new ResolveDuplicateLabelDialog(panel,key,dupes.get(key));
    rdld.show();
    if (rdld.isOkPressed()) {
      List<JCheckBox> cbs=rdld.getCheckBoxes();
      for (int i=0; i < cbs.size(); i++) {
        if (cbs.get(i).isSelected()) {
          toGenerateFor.add(dupes.get(key).get(i));
        }
      }
    }
  }
  if (!toGenerateFor.isEmpty()) {
    NamedCompound ce=new NamedCompound("resolve duplicate keys");
    for (    BibtexEntry entry : toGenerateFor) {
      String oldKey=entry.getCiteKey();
      entry=LabelPatternUtil.makeLabel(panel.metaData(),panel.database(),entry);
      ce.addEdit(new UndoableKeyChange(panel.database(),entry.getId(),oldKey,entry.getField(BibtexFields.KEY_FIELD)));
    }
    ce.end();
    panel.undoManager.addEdit(ce);
    panel.markBaseChanged();
  }
  panel.output(Globals.lang("Finished resolving duplicate BibTeX keys. %0 entries modified.",String.valueOf(toGenerateFor.size())));
}
