{
  Globals.prefs=JabRefPreferences.getInstance();
  BibtexParser parser=new BibtexParser(new FileReader(args[0]));
  ParserResult result=parser.parse();
  BibDatabase db=result.getDatabase();
  int total=result.getDatabase().getEntryCount();
  AtomicInteger dois=new AtomicInteger();
  AtomicInteger doiFound=new AtomicInteger();
  AtomicInteger doiNew=new AtomicInteger();
  AtomicInteger doiIdentical=new AtomicInteger();
  List<BibEntry> entries=db.getEntries();
  CountDownLatch countDownLatch=new CountDownLatch(entries.size());
  ExecutorService executorService=Executors.newFixedThreadPool(5);
  for (  BibEntry entry : entries) {
    executorService.execute(new Runnable(){
      @Override public void run(){
        Optional<DOI> origDOI=DOI.build(entry.getField("doi"));
        if (origDOI.isPresent()) {
          dois.incrementAndGet();
          Optional<DOI> crossrefDOI=CrossRef.findDOI(entry);
          if (crossrefDOI.isPresent()) {
            doiFound.incrementAndGet();
            if (origDOI.get().getDOI().equalsIgnoreCase(crossrefDOI.get().getDOI())) {
              doiIdentical.incrementAndGet();
            }
 else {
              System.out.println("DOI not identical for : " + entry);
            }
          }
 else {
            System.out.println("DOI not found for: " + entry);
          }
        }
 else {
          Optional<DOI> crossrefDOI=CrossRef.findDOI(entry);
          if (crossrefDOI.isPresent()) {
            System.out.println("New DOI found for: " + entry);
            doiNew.incrementAndGet();
          }
        }
        countDownLatch.countDown();
      }
    }
);
  }
  countDownLatch.await();
  System.out.println("---------------------------------");
  System.out.println("Total DB size: " + total);
  System.out.println("Total DOIs: " + dois);
  System.out.println("DOIs found: " + doiFound);
  System.out.println("DOIs identical: " + doiIdentical);
  System.out.println("New DOIs found: " + doiNew);
  executorService.shutdown();
}
