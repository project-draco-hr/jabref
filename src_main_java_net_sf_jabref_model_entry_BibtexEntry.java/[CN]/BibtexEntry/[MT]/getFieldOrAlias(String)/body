{
  String fieldValue=getField(name);
  if (fieldValue != null && !fieldValue.isEmpty()) {
    return fieldValue;
  }
  String aliasForField=EntryConverter.FIELD_ALIASES.get(name);
  if (aliasForField != null) {
    return getField(aliasForField);
  }
  if (name.equals("date")) {
    String year=getField("year");
    MonthUtil.Month month=MonthUtil.getMonth(getField("month"));
    if (year != null) {
      if (month.isValid()) {
        return year + '-' + month.twoDigitNumber;
      }
 else {
        return year;
      }
    }
  }
  if (name.equals("year") || name.equals("month")) {
    String date=getField("date");
    if (date == null) {
      return null;
    }
    DateFormat df=new DateFormat(){
      static final String FORMAT1="yyyy-MM-dd";
      static final String FORMAT2="yyyy-MM";
      final SimpleDateFormat sdf1=new SimpleDateFormat(FORMAT1);
      final SimpleDateFormat sdf2=new SimpleDateFormat(FORMAT2);
      @Override public StringBuffer format(      Date date,      StringBuffer toAppendTo,      FieldPosition fieldPosition){
        throw new UnsupportedOperationException();
      }
      @Override public Date parse(      String source,      ParsePosition pos){
        if (source.length() - pos.getIndex() == FORMAT1.length()) {
          return sdf1.parse(source,pos);
        }
        return sdf2.parse(source,pos);
      }
    }
;
    try {
      Date parsedDate=df.parse(date);
      Calendar calendar=Calendar.getInstance();
      calendar.setTime(parsedDate);
      if (name.equals("year")) {
        return Integer.toString(calendar.get(Calendar.YEAR));
      }
      if (name.equals("month")) {
        return Integer.toString(calendar.get(Calendar.MONTH) + 1);
      }
    }
 catch (    ParseException e) {
      df=new SimpleDateFormat("yyyy");
      try {
        Date parsedDate=df.parse(date);
        Calendar calendar=Calendar.getInstance();
        calendar.setTime(parsedDate);
        if (name.equals("year")) {
          return Integer.toString(calendar.get(Calendar.YEAR));
        }
      }
 catch (      ParseException e2) {
        LOGGER.warn("Could not parse entry " + name,e);
        return null;
      }
    }
  }
  return null;
}
